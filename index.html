<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MR Studio Diamond V24 - FIXED</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/omggif@1.0.10/omggif.min.js"></script>
    <style>
        :root {
            --ui-primary: #ffaa00;
            --ui-secondary: #ff8800;
            --ui-bg: rgba(0, 0, 0, 0.85);
            --ui-text: #ffffff;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #ui-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel {
            background: var(--ui-bg);
            border: 2px solid var(--ui-primary);
            border-radius: 12px;
            padding: 15px;
            color: var(--ui-text);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            max-width: 320px;
        }

        .panel-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
            color: var(--ui-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn {
            background: linear-gradient(135deg, var(--ui-primary), var(--ui-secondary));
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(255, 170, 0, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 170, 0, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #555, #333);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
        }

        input[type="text"], input[type="file"], select {
            width: 100%;
            padding: 8px;
            margin: 6px 0;
            border: 1px solid var(--ui-primary);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 13px;
        }

        input[type="range"] {
            width: 100%;
            margin: 8px 0;
        }

        .slider-group {
            margin: 10px 0;
        }

        .slider-label {
            font-size: 12px;
            color: #ccc;
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .color-scheme-selector {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .color-btn {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .color-btn:hover {
            transform: scale(1.1);
            border-color: white;
        }

        .color-btn.active {
            border-color: white;
            box-shadow: 0 0 12px white;
        }

        .color-btn::after {
            content: attr(data-name);
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            white-space: nowrap;
            color: #aaa;
        }

        #asset-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .asset-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            margin: 5px 0;
            border-radius: 6px;
            border-left: 3px solid var(--ui-primary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .asset-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .asset-item.selected {
            background: rgba(255, 170, 0, 0.3);
            border-left-color: white;
        }

        .toggle-btn {
            background: transparent;
            border: 2px solid var(--ui-primary);
            color: var(--ui-primary);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .toggle-btn.active {
            background: var(--ui-primary);
            color: black;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--ui-primary);
            border-radius: 8px;
            padding: 15px 20px;
            color: white;
            z-index: 20000;
            animation: slideIn 0.3s ease;
            max-width: 300px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .hidden {
            display: none;
        }

        #file-info {
            font-size: 11px;
            color: #aaa;
            margin-top: 5px;
        }

        .section-divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--ui-primary), transparent);
            margin: 15px 0;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--ui-primary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--ui-secondary);
        }

        .grid-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .save-load-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .drive-status {
            font-size: 11px;
            color: #4CAF50;
            margin-top: 5px;
        }

        .drive-status.disconnected {
            color: #ff5555;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <!-- Panel de Color UI -->
        <div class="panel">
            <div class="panel-title">üé® Color UI</div>
            <div class="color-scheme-selector">
                <div class="color-btn active" data-scheme="amber" data-name="√Åmbar" style="background: linear-gradient(135deg, #ffaa00, #ff8800)"></div>
                <div class="color-btn" data-scheme="earth" data-name="Tierra" style="background: linear-gradient(135deg, #8b6f47, #654321)"></div>
                <div class="color-btn" data-scheme="tech" data-name="Tech" style="background: linear-gradient(135deg, #00d9ff, #0099cc)"></div>
                <div class="color-btn" data-scheme="passion" data-name="Passion" style="background: linear-gradient(135deg, #ff3366, #cc0044)"></div>
                <div class="color-btn" data-scheme="architecture" data-name="Arch" style="background: linear-gradient(135deg, #e0e0e0, #b0b0b0)"></div>
            </div>
        </div>

        <!-- Panel de Guardado/Carga -->
        <div class="panel">
            <div class="panel-title">üíæ Escena</div>
            <div class="save-load-section">
                <button class="btn" onclick="saveSceneLocal()">üíæ Guardar Local</button>
                <button class="btn btn-secondary" onclick="document.getElementById('load-scene-input').click()">üìÇ Cargar Local</button>
                <input type="file" id="load-scene-input" accept=".json" style="display: none" onchange="loadSceneLocal(event)">
                
                <div class="section-divider"></div>
                
                <button class="btn" id="drive-connect-btn" onclick="connectGoogleDrive()">üîó Conectar Drive</button>
                <div id="drive-status" class="drive-status disconnected">‚ö† Desconectado</div>
                <div id="drive-controls" class="hidden">
                    <button class="btn" onclick="saveSceneToDrive()">‚òÅÔ∏è Guardar a Drive</button>
                    <button class="btn btn-secondary" onclick="loadSceneFromDrive()">‚òÅÔ∏è Cargar de Drive</button>
                </div>
            </div>
        </div>

        <!-- Panel Principal -->
        <div class="panel">
            <div class="panel-title">üåå Universo</div>
            <input type="text" id="url-input" placeholder="URL (YouTube, Imagen, Video, Modelo 3D)">
            <input type="file" id="file-input" accept="image/*,video/*,.glb,.gltf,.obj,.fbx">
            <div id="file-info"></div>
            
            <div class="section-divider"></div>
            
            <div class="slider-group">
                <div class="slider-label">
                    <span>üìè Escala</span>
                    <span id="scale-value">1.0</span>
                </div>
                <input type="range" id="scale-slider" min="0.1" max="10" step="0.1" value="1">
            </div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>üé≠ Proyecci√≥n</span>
                </div>
                <select id="projection-type">
                    <option value="plane">Plano</option>
                    <option value="sphere">Esfera 360¬∞</option>
                    <option value="cylinder">Cilindro 180¬∞</option>
                    <option value="dome">Domo</option>
                </select>
            </div>

            <div class="grid-layout">
                <button class="btn" onclick="addUniverse()">‚ûï Crear</button>
                <button class="btn btn-secondary" onclick="deleteSelected()">üóëÔ∏è Borrar</button>
            </div>
        </div>

        <!-- Panel de Transform -->
        <div class="panel">
            <div class="panel-title">üîß Transform (Tiempo Real)</div>
            
            <div class="slider-group">
                <div class="slider-label"><span>X</span><span id="pos-x-val">0</span></div>
                <input type="range" id="pos-x" min="-20" max="20" step="0.1" value="0" oninput="updateTransformRT()">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>Y</span><span id="pos-y-val">1.6</span></div>
                <input type="range" id="pos-y" min="-10" max="10" step="0.1" value="1.6" oninput="updateTransformRT()">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>Z</span><span id="pos-z-val">-4</span></div>
                <input type="range" id="pos-z" min="-30" max="5" step="0.1" value="-4" oninput="updateTransformRT()">
            </div>

            <div class="section-divider"></div>

            <div class="slider-group">
                <div class="slider-label"><span>üîÑ Rot X</span><span id="rot-x-val">0</span></div>
                <input type="range" id="rot-x" min="-180" max="180" step="1" value="0" oninput="updateTransformRT()">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>üîÑ Rot Y</span><span id="rot-y-val">0</span></div>
                <input type="range" id="rot-y" min="-180" max="180" step="1" value="0" oninput="updateTransformRT()">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>üîÑ Rot Z</span><span id="rot-z-val">0</span></div>
                <input type="range" id="rot-z" min="-180" max="180" step="1" value="0" oninput="updateTransformRT()">
            </div>
        </div>

        <!-- Panel de Shaders -->
        <div class="panel">
            <div class="panel-title">‚ú® Shaders (Tiempo Real)</div>
            
            <div class="slider-group">
                <div class="slider-label"><span>üåà Brillo</span><span id="brightness-val">1.0</span></div>
                <input type="range" id="brightness" min="0" max="3" step="0.1" value="1" oninput="updateShadersRT()">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>üé® Contraste</span><span id="contrast-val">1.0</span></div>
                <input type="range" id="contrast" min="0" max="3" step="0.1" value="1" oninput="updateShadersRT()">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>üíß Saturaci√≥n</span><span id="saturation-val">1.0</span></div>
                <input type="range" id="saturation" min="0" max="3" step="0.1" value="1" oninput="updateShadersRT()">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>üå°Ô∏è Temperatura</span><span id="temperature-val">0.0</span></div>
                <input type="range" id="temperature" min="-1" max="1" step="0.1" value="0" oninput="updateShadersRT()">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>üî≥ Blur</span><span id="blur-val">0.0</span></div>
                <input type="range" id="blur" min="0" max="0.05" step="0.001" value="0" oninput="updateShadersRT()">
            </div>

            <button class="btn" onclick="resetShaders()">üîÑ Reset</button>
        </div>

        <!-- Panel de Video -->
        <div class="panel" id="video-panel" style="display: none;">
            <div class="panel-title">üé¨ Video</div>
            
            <div class="slider-group">
                <div class="slider-label"><span>‚è±Ô∏è Inicio</span><span id="trim-start-val">0s</span></div>
                <input type="range" id="trim-start" min="0" max="100" step="0.1" value="0" oninput="updateVideoTrimRT()">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>‚è±Ô∏è Fin</span><span id="trim-end-val">100s</span></div>
                <input type="range" id="trim-end" min="0" max="100" step="0.1" value="100" oninput="updateVideoTrimRT()">
            </div>

            <div class="grid-layout">
                <button class="toggle-btn" id="loop-btn" onclick="toggleLoop()">üîÅ Loop</button>
                <button class="toggle-btn" id="mute-btn" onclick="toggleMute()">üîá Mute</button>
            </div>
        </div>

        <!-- Lista de Assets -->
        <div class="panel">
            <div class="panel-title">üì¶ Assets</div>
            <div id="asset-list"></div>
        </div>
    </div>

    <a-scene
        renderer="colorManagement: true; physicallyCorrectLights: true; antialias: true; alpha: true;"
        webxr="requiredFeatures: hit-test,local-floor; optionalFeatures: dom-overlay,hand-tracking,depth-sensing; overlayElement: #ui-container;">
        
        <a-assets>
            <video id="video-player" crossorigin="anonymous" preload="metadata"></video>
        </a-assets>

        <a-entity id="rig" position="0 0 0">
            <a-camera id="camera" position="0 1.6 0" wasd-controls-enabled="true" look-controls-enabled="true">
                <a-entity
                    cursor="rayOrigin: mouse"
                    raycaster="objects: .interactive; far: 100">
                </a-entity>
            </a-camera>
        </a-entity>

        <a-entity light="type: ambient; intensity: 0.5"></a-entity>
        <a-entity light="type: directional; intensity: 0.8" position="1 2 1"></a-entity>

        <a-sky color="#000814"></a-sky>
    </a-scene>

    <script>
        // ============================================
        // SISTEMA DE COLOR UI
        // ============================================
        const COLOR_SCHEMES = {
            amber: { primary: '#ffaa00', secondary: '#ff8800' },
            earth: { primary: '#8b6f47', secondary: '#654321' },
            tech: { primary: '#00d9ff', secondary: '#0099cc' },
            passion: { primary: '#ff3366', secondary: '#cc0044' },
            architecture: { primary: '#e0e0e0', secondary: '#b0b0b0' }
        };

        function initColorScheme() {
            const saved = localStorage.getItem('ui-color-scheme') || 'amber';
            applyColorScheme(saved);

            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const scheme = btn.dataset.scheme;
                    applyColorScheme(scheme);
                    localStorage.setItem('ui-color-scheme', scheme);
                });
            });
        }

        function applyColorScheme(scheme) {
            const colors = COLOR_SCHEMES[scheme];
            document.documentElement.style.setProperty('--ui-primary', colors.primary);
            document.documentElement.style.setProperty('--ui-secondary', colors.secondary);

            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.scheme === scheme);
            });
        }

        // ============================================
        // VARIABLES GLOBALES
        // ============================================
        let universes = [];
        let selectedUniverse = null;
        let universeCounter = 0;
        let driveAccessToken = null;

        // ============================================
        // SHADER COMPONENTS
        // ============================================
        AFRAME.registerShader('video-shader', {
            schema: {
                src: { type: 'map', is: 'uniform' },
                brightness: { type: 'number', is: 'uniform', default: 1.0 },
                contrast: { type: 'number', is: 'uniform', default: 1.0 },
                saturation: { type: 'number', is: 'uniform', default: 1.0 },
                temperature: { type: 'number', is: 'uniform', default: 0.0 },
                blur: { type: 'number', is: 'uniform', default: 0.0 }
            },

            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,

            fragmentShader: `
                uniform sampler2D src;
                uniform float brightness;
                uniform float contrast;
                uniform float saturation;
                uniform float temperature;
                uniform float blur;
                varying vec2 vUv;

                vec3 adjustTemperature(vec3 color, float temp) {
                    vec3 warm = vec3(1.0, 0.9, 0.7);
                    vec3 cool = vec3(0.7, 0.9, 1.0);
                    return color * mix(cool, warm, temp * 0.5 + 0.5);
                }

                void main() {
                    vec4 texel = texture2D(src, vUv);
                    
                    if (blur > 0.0) {
                        vec4 blurred = vec4(0.0);
                        float total = 0.0;
                        for (float x = -2.0; x <= 2.0; x += 1.0) {
                            for (float y = -2.0; y <= 2.0; y += 1.0) {
                                vec2 offset = vec2(x, y) * blur;
                                blurred += texture2D(src, vUv + offset);
                                total += 1.0;
                            }
                        }
                        texel = blurred / total;
                    }

                    vec3 color = texel.rgb * brightness;
                    color = ((color - 0.5) * contrast) + 0.5;
                    
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    color = mix(vec3(gray), color, saturation);
                    
                    color = adjustTemperature(color, temperature);
                    color = clamp(color, 0.0, 1.0);

                    gl_FragColor = vec4(color, texel.a);
                }
            `
        });

        // Depth Occlusion mejorado para Meta Quest
        AFRAME.registerComponent('depth-occlusion', {
            schema: {
                enabled: { type: 'boolean', default: true },
                near: { type: 'number', default: 0.01 },
                far: { type: 'number', default: 10.0 }
            },

            init: function() {
                this.depthTexture = null;
                this.setupDepthSensing();
            },

            setupDepthSensing: function() {
                const sceneEl = this.el.sceneEl;
                
                if (!sceneEl.renderer || !sceneEl.renderer.xr) {
                    console.warn('[Depth] Renderer XR no disponible');
                    return;
                }

                const xr = sceneEl.renderer.xr;
                const session = xr.getSession();

                if (!session) {
                    console.log('[Depth] Esperando sesi√≥n XR...');
                    sceneEl.addEventListener('enter-vr', () => {
                        setTimeout(() => this.setupDepthSensing(), 500);
                    });
                    return;
                }

                if (!session.depthUsage) {
                    console.warn('[Depth] Depth sensing no habilitado en sesi√≥n');
                    return;
                }

                console.log('[Depth] ‚úÖ Depth sensing activo');
                this.createDepthMaterial();
            },

            createDepthMaterial: function() {
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        depthTexture: { value: null },
                        cameraNear: { value: this.data.near },
                        cameraFar: { value: this.data.far }
                    },

                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,

                    fragmentShader: `
                        uniform sampler2D depthTexture;
                        uniform float cameraNear;
                        uniform float cameraFar;
                        varying vec2 vUv;

                        float readDepth(sampler2D depthMap, vec2 coord) {
                            vec4 depthSample = texture2D(depthMap, coord);
                            
                            // Luminance-alpha format
                            if (depthSample.a > 0.0) {
                                return depthSample.r;
                            }
                            
                            // Float32 format
                            return depthSample.r;
                        }

                        float perspectiveDepthToViewZ(float invClipZ, float near, float far) {
                            return (near * far) / ((far - near) * invClipZ - far);
                        }

                        void main() {
                            float depth = readDepth(depthTexture, vUv);
                            
                            if (depth <= 0.0 || depth >= 1.0) {
                                discard;
                            }

                            float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
                            float normalizedDepth = (viewZ + cameraNear) / (cameraFar - cameraNear);
                            normalizedDepth = clamp(normalizedDepth, 0.0, 1.0);

                            gl_FragColor = vec4(vec3(normalizedDepth), 1.0);
                        }
                    `,

                    transparent: true,
                    depthTest: true,
                    depthWrite: true
                });

                this.depthMaterial = material;
                console.log('[Depth] Material creado');
            },

            tick: function() {
                if (!this.data.enabled || !this.depthMaterial) return;

                const sceneEl = this.el.sceneEl;
                const xr = sceneEl.renderer?.xr;
                const frame = xr?.getFrame?.();

                if (!frame) return;

                try {
                    const pose = frame.getViewerPose(xr.getReferenceSpace());
                    if (!pose || !pose.views || pose.views.length === 0) return;

                    const view = pose.views[0];
                    const depthInfo = frame.getDepthInformation?.(view);

                    if (depthInfo && depthInfo.texture) {
                        this.depthMaterial.uniforms.depthTexture.value = depthInfo.texture;
                        this.depthMaterial.uniforms.cameraNear.value = depthInfo.rawValueToMeters * this.data.near;
                        this.depthMaterial.uniforms.cameraFar.value = depthInfo.rawValueToMeters * this.data.far;
                    }
                } catch (e) {
                    // Silenciar errores normales de frame timing
                }
            }
        });

        // ============================================
        // FUNCIONES DE UNIVERSO
        // ============================================
        async function addUniverse() {
            const url = document.getElementById('url-input').value.trim();
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];

            if (!url && !file) {
                showNotification('‚ùå Proporciona URL o archivo');
                return;
            }

            const scale = parseFloat(document.getElementById('scale-slider').value);
            const projection = document.getElementById('projection-type').value;

            let assetUrl = url;
            let assetType = 'unknown';
            let isLocal = false;

            if (file) {
                assetUrl = URL.createObjectURL(file);
                assetType = detectAssetType(file.name);
                isLocal = true;
            } else {
                assetType = detectAssetType(url);
            }

            // CORRECCI√ìN 1: Bloquear proyecciones para YouTube y Modelos 3D
            if (assetType === 'youtube' || assetType === 'model') {
                if (projection !== 'plane') {
                    showNotification('‚ö†Ô∏è YouTube y modelos 3D solo soportan proyecci√≥n PLANO');
                    document.getElementById('projection-type').value = 'plane';
                }
            }

            const universe = {
                id: `universe-${universeCounter++}`,
                url: assetUrl,
                type: assetType,
                projection: assetType === 'youtube' || assetType === 'model' ? 'plane' : projection,
                scale: scale,
                position: { x: 0, y: 1.6, z: -4 },
                rotation: { x: 0, y: 0, z: 0 },
                shaders: {
                    brightness: 1,
                    contrast: 1,
                    saturation: 1,
                    temperature: 0,
                    blur: 0
                },
                videoSettings: {
                    loop: true,
                    muted: false,
                    trimStart: 0,
                    trimEnd: 100
                },
                isLocal: isLocal,
                localFile: isLocal ? file : null
            };

            universes.push(universe);
            await createUniverseEntity(universe);
            updateAssetList();
            selectUniverse(universe);
            showNotification(`‚úÖ Universo creado: ${assetType.toUpperCase()}`);
        }

        async function createUniverseEntity(universe) {
            const scene = document.querySelector('a-scene');
            const entity = document.createElement('a-entity');
            entity.setAttribute('id', universe.id);
            entity.classList.add('interactive');

            const pos = universe.position;
            const rot = universe.rotation;
            entity.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
            entity.setAttribute('rotation', `${rot.x} ${rot.y} ${rot.z}`);

            // Depth occlusion
            entity.setAttribute('depth-occlusion', 'enabled: true; near: 0.01; far: 10.0');

            if (universe.type === 'youtube') {
                await setupYouTube(entity, universe);
            } else if (universe.type === 'video') {
                await setupVideo(entity, universe);
            } else if (universe.type === 'image') {
                await setupImage(entity, universe);
            } else if (universe.type === 'gif') {
                await setupGIF(entity, universe);
            } else if (universe.type === 'model') {
                await setupModel(entity, universe);
            }

            scene.appendChild(entity);
            universe.entity = entity;
        }

        async function setupYouTube(entity, universe) {
            const videoId = extractYouTubeId(universe.url);
            if (!videoId) {
                showNotification('‚ùå URL de YouTube inv√°lida');
                return;
            }

            const iframe = document.createElement('iframe');
            iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&loop=1&playlist=${videoId}&controls=1`;
            iframe.style.width = '1920px';
            iframe.style.height = '1080px';
            iframe.style.border = 'none';
            document.body.appendChild(iframe);

            const canvas = document.createElement('canvas');
            canvas.width = 1920;
            canvas.height = 1080;
            const ctx = canvas.getContext('2d');

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            applyProjection(entity, universe, texture);

            universe.youtubeData = { iframe, canvas, ctx, texture };
        }

        async function setupVideo(entity, universe) {
            const video = document.createElement('video');
            video.src = universe.url;
            video.crossOrigin = 'anonymous';
            video.loop = universe.videoSettings.loop;
            video.muted = universe.videoSettings.muted;
            video.autoplay = true;
            video.playsInline = true;

            const texture = new THREE.VideoTexture(video);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;

            applyProjection(entity, universe, texture);
            applyShaders(entity, universe);

            video.play().catch(e => console.warn('Video play error:', e));
            universe.videoElement = video;
        }

        async function setupImage(entity, universe) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = () => {
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    applyProjection(entity, universe, texture);
                    applyShaders(entity, universe);
                    resolve();
                };

                img.onerror = () => {
                    showNotification('‚ùå Error al cargar imagen');
                    resolve();
                };

                img.src = universe.url;
                universe.imageElement = img;
            });
        }

        // CORRECCI√ìN 2: Arreglar apertura de GIF con FileReader
        async function setupGIF(entity, universe) {
            return new Promise((resolve) => {
                if (universe.isLocal && universe.localFile) {
                    // Usar FileReader para archivos locales
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        const arrayBuffer = e.target.result;
                        processGIFData(new Uint8Array(arrayBuffer), entity, universe);
                        resolve();
                    };

                    reader.onerror = () => {
                        showNotification('‚ùå Error al leer GIF');
                        resolve();
                    };

                    reader.readAsArrayBuffer(universe.localFile);
                } else {
                    // Usar fetch para URLs remotas
                    fetch(universe.url)
                        .then(r => r.arrayBuffer())
                        .then(buffer => {
                            processGIFData(new Uint8Array(buffer), entity, universe);
                            resolve();
                        })
                        .catch(() => {
                            showNotification('‚ùå Error al descargar GIF');
                            resolve();
                        });
                }
            });
        }

        function processGIFData(uint8Array, entity, universe) {
            if (typeof GifReader === 'undefined') {
                showNotification('‚ö†Ô∏è Librer√≠a omggif no cargada, mostrando como imagen est√°tica');
                setupImage(entity, universe);
                return;
            }

            try {
                const reader = new GifReader(uint8Array);
                const info = reader.frameInfo(0);
                const canvas = document.createElement('canvas');
                canvas.width = reader.width;
                canvas.height = reader.height;
                const ctx = canvas.getContext('2d');

                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const texture = new THREE.CanvasTexture(canvas);

                let frameIndex = 0;
                setInterval(() => {
                    reader.decodeAndBlitFrameRGBA(frameIndex, imageData.data);
                    ctx.putImageData(imageData, 0, 0);
                    texture.needsUpdate = true;
                    frameIndex = (frameIndex + 1) % reader.numFrames();
                }, info.delay * 10);

                applyProjection(entity, universe, texture);
                applyShaders(entity, universe);
            } catch (e) {
                console.error('Error procesando GIF:', e);
                showNotification('‚ùå Error al procesar GIF');
            }
        }

        async function setupModel(entity, universe) {
            entity.setAttribute('gltf-model', universe.url);
            entity.setAttribute('scale', `${universe.scale} ${universe.scale} ${universe.scale}`);
            entity.setAttribute('animation-mixer', '');
        }

        function applyProjection(entity, universe, texture) {
            const scale = universe.scale;

            if (universe.projection === 'plane') {
                const geometry = new THREE.PlaneGeometry(4 * scale, 2.25 * scale);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geometry, material);
                entity.setObject3D('mesh', mesh);
            } else if (universe.projection === 'sphere') {
                const geometry = new THREE.SphereGeometry(10 * scale, 64, 64);
                geometry.scale(-1, 1, 1);
                const material = new THREE.MeshBasicMaterial({ map: texture });
                const mesh = new THREE.Mesh(geometry, material);
                entity.setObject3D('mesh', mesh);
            } else if (universe.projection === 'cylinder') {
                const geometry = new THREE.CylinderGeometry(8 * scale, 8 * scale, 6 * scale, 64, 1, true);
                geometry.scale(-1, 1, 1);
                const material = new THREE.MeshBasicMaterial({ map: texture });
                const mesh = new THREE.Mesh(geometry, material);
                entity.setObject3D('mesh', mesh);
            } else if (universe.projection === 'dome') {
                const geometry = new THREE.SphereGeometry(10 * scale, 64, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                geometry.scale(-1, 1, 1);
                const material = new THREE.MeshBasicMaterial({ map: texture });
                const mesh = new THREE.Mesh(geometry, material);
                entity.setObject3D('mesh', mesh);
            }
        }

        function applyShaders(entity, universe) {
            const mesh = entity.getObject3D('mesh');
            if (!mesh) return;

            const shader = universe.shaders;
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    src: { value: mesh.material.map },
                    brightness: { value: shader.brightness },
                    contrast: { value: shader.contrast },
                    saturation: { value: shader.saturation },
                    temperature: { value: shader.temperature },
                    blur: { value: shader.blur }
                },
                vertexShader: AFRAME.shaders['video-shader'].vertexShader,
                fragmentShader: AFRAME.shaders['video-shader'].fragmentShader,
                side: THREE.DoubleSide
            });

            mesh.material = material;
        }

        // CORRECCI√ìN 3: Editores en Tiempo Real
        function updateTransformRT() {
            if (!selectedUniverse) return;

            const x = parseFloat(document.getElementById('pos-x').value);
            const y = parseFloat(document.getElementById('pos-y').value);
            const z = parseFloat(document.getElementById('pos-z').value);
            const rx = parseFloat(document.getElementById('rot-x').value);
            const ry = parseFloat(document.getElementById('rot-y').value);
            const rz = parseFloat(document.getElementById('rot-z').value);

            document.getElementById('pos-x-val').textContent = x.toFixed(1);
            document.getElementById('pos-y-val').textContent = y.toFixed(1);
            document.getElementById('pos-z-val').textContent = z.toFixed(1);
            document.getElementById('rot-x-val').textContent = rx;
            document.getElementById('rot-y-val').textContent = ry;
            document.getElementById('rot-z-val').textContent = rz;

            selectedUniverse.position = { x, y, z };
            selectedUniverse.rotation = { x: rx, y: ry, z: rz };

            if (selectedUniverse.entity) {
                selectedUniverse.entity.setAttribute('position', `${x} ${y} ${z}`);
                selectedUniverse.entity.setAttribute('rotation', `${rx} ${ry} ${rz}`);
            }
        }

        function updateShadersRT() {
            if (!selectedUniverse) return;

            const brightness = parseFloat(document.getElementById('brightness').value);
            const contrast = parseFloat(document.getElementById('contrast').value);
            const saturation = parseFloat(document.getElementById('saturation').value);
            const temperature = parseFloat(document.getElementById('temperature').value);
            const blur = parseFloat(document.getElementById('blur').value);

            document.getElementById('brightness-val').textContent = brightness.toFixed(1);
            document.getElementById('contrast-val').textContent = contrast.toFixed(1);
            document.getElementById('saturation-val').textContent = saturation.toFixed(1);
            document.getElementById('temperature-val').textContent = temperature.toFixed(1);
            document.getElementById('blur-val').textContent = blur.toFixed(3);

            selectedUniverse.shaders = { brightness, contrast, saturation, temperature, blur };
            applyShaders(selectedUniverse.entity, selectedUniverse);
        }

        function updateVideoTrimRT() {
            if (!selectedUniverse || !selectedUniverse.videoElement) return;

            const start = parseFloat(document.getElementById('trim-start').value);
            const end = parseFloat(document.getElementById('trim-end').value);

            document.getElementById('trim-start-val').textContent = `${start.toFixed(1)}s`;
            document.getElementById('trim-end-val').textContent = `${end.toFixed(1)}s`;

            selectedUniverse.videoSettings.trimStart = start;
            selectedUniverse.videoSettings.trimEnd = end;

            const video = selectedUniverse.videoElement;
            if (video.duration) {
                video.currentTime = (start / 100) * video.duration;
            }
        }

        function resetShaders() {
            if (!selectedUniverse) return;

            document.getElementById('brightness').value = 1;
            document.getElementById('contrast').value = 1;
            document.getElementById('saturation').value = 1;
            document.getElementById('temperature').value = 0;
            document.getElementById('blur').value = 0;

            updateShadersRT();
            showNotification('üîÑ Shaders reseteados');
        }

        function toggleLoop() {
            if (!selectedUniverse || !selectedUniverse.videoElement) return;
            const btn = document.getElementById('loop-btn');
            selectedUniverse.videoSettings.loop = !selectedUniverse.videoSettings.loop;
            selectedUniverse.videoElement.loop = selectedUniverse.videoSettings.loop;
            btn.classList.toggle('active', selectedUniverse.videoSettings.loop);
        }

        function toggleMute() {
            if (!selectedUniverse || !selectedUniverse.videoElement) return;
            const btn = document.getElementById('mute-btn');
            selectedUniverse.videoSettings.muted = !selectedUniverse.videoSettings.muted;
            selectedUniverse.videoElement.muted = selectedUniverse.videoSettings.muted;
            btn.classList.toggle('active', selectedUniverse.videoSettings.muted);
        }

        function selectUniverse(universe) {
            selectedUniverse = universe;

            // Actualizar controles de transform
            document.getElementById('pos-x').value = universe.position.x;
            document.getElementById('pos-y').value = universe.position.y;
            document.getElementById('pos-z').value = universe.position.z;
            document.getElementById('rot-x').value = universe.rotation.x;
            document.getElementById('rot-y').value = universe.rotation.y;
            document.getElementById('rot-z').value = universe.rotation.z;

            document.getElementById('pos-x-val').textContent = universe.position.x.toFixed(1);
            document.getElementById('pos-y-val').textContent = universe.position.y.toFixed(1);
            document.getElementById('pos-z-val').textContent = universe.position.z.toFixed(1);
            document.getElementById('rot-x-val').textContent = universe.rotation.x;
            document.getElementById('rot-y-val').textContent = universe.rotation.y;
            document.getElementById('rot-z-val').textContent = universe.rotation.z;

            // Actualizar shaders
            document.getElementById('brightness').value = universe.shaders.brightness;
            document.getElementById('contrast').value = universe.shaders.contrast;
            document.getElementById('saturation').value = universe.shaders.saturation;
            document.getElementById('temperature').value = universe.shaders.temperature;
            document.getElementById('blur').value = universe.shaders.blur;

            document.getElementById('brightness-val').textContent = universe.shaders.brightness.toFixed(1);
            document.getElementById('contrast-val').textContent = universe.shaders.contrast.toFixed(1);
            document.getElementById('saturation-val').textContent = universe.shaders.saturation.toFixed(1);
            document.getElementById('temperature-val').textContent = universe.shaders.temperature.toFixed(1);
            document.getElementById('blur-val').textContent = universe.shaders.blur.toFixed(3);

            // Mostrar panel de video si es necesario
            const videoPanel = document.getElementById('video-panel');
            if (universe.type === 'video' && universe.videoElement) {
                videoPanel.style.display = 'block';
                document.getElementById('loop-btn').classList.toggle('active', universe.videoSettings.loop);
                document.getElementById('mute-btn').classList.toggle('active', universe.videoSettings.muted);
            } else {
                videoPanel.style.display = 'none';
            }

            // Actualizar proyecci√≥n
            document.getElementById('projection-type').value = universe.projection;
            
            // BLOQUEAR selector de proyecci√≥n para YouTube y modelos
            document.getElementById('projection-type').disabled = (universe.type === 'youtube' || universe.type === 'model');

            updateAssetList();
        }

        function deleteSelected() {
            if (!selectedUniverse) {
                showNotification('‚ö†Ô∏è Selecciona un universo');
                return;
            }

            if (selectedUniverse.entity) {
                selectedUniverse.entity.remove();
            }

            universes = universes.filter(u => u.id !== selectedUniverse.id);
            selectedUniverse = null;
            updateAssetList();
            showNotification('üóëÔ∏è Universo eliminado');
        }

        function updateAssetList() {
            const list = document.getElementById('asset-list');
            list.innerHTML = '';

            universes.forEach(universe => {
                const item = document.createElement('div');
                item.className = 'asset-item';
                if (selectedUniverse && selectedUniverse.id === universe.id) {
                    item.classList.add('selected');
                }

                const icon = {
                    youtube: 'üì∫',
                    video: 'üé¨',
                    image: 'üñºÔ∏è',
                    gif: 'üéûÔ∏è',
                    model: 'üé≠'
                }[universe.type] || 'üì¶';

                item.innerHTML = `${icon} ${universe.type.toUpperCase()} - ${universe.id}`;
                item.onclick = () => selectUniverse(universe);
                list.appendChild(item);
            });
        }

        // ============================================
        // SISTEMA DE GUARDADO/CARGA JSON
        // ============================================
        function saveSceneLocal() {
            const sceneData = {
                version: '24.0',
                timestamp: new Date().toISOString(),
                universes: universes.map(u => ({
                    id: u.id,
                    url: u.url,
                    type: u.type,
                    projection: u.projection,
                    scale: u.scale,
                    position: u.position,
                    rotation: u.rotation,
                    shaders: u.shaders,
                    videoSettings: u.videoSettings,
                    isLocal: u.isLocal
                }))
            };

            const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mr-studio-scene-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            showNotification('üíæ Escena guardada localmente');
        }

        function loadSceneLocal(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const sceneData = JSON.parse(e.target.result);
                    
                    // Limpiar escena actual
                    universes.forEach(u => {
                        if (u.entity) u.entity.remove();
                    });
                    universes = [];
                    selectedUniverse = null;

                    // Restaurar universos
                    for (const uData of sceneData.universes) {
                        if (uData.isLocal) {
                            showNotification('‚ö†Ô∏è Assets locales requieren volver a seleccionarse');
                            continue;
                        }

                        const universe = {
                            id: uData.id,
                            url: uData.url,
                            type: uData.type,
                            projection: uData.projection,
                            scale: uData.scale,
                            position: uData.position,
                            rotation: uData.rotation,
                            shaders: uData.shaders,
                            videoSettings: uData.videoSettings,
                            isLocal: false,
                            localFile: null
                        };

                        universes.push(universe);
                        await createUniverseEntity(universe);
                    }

                    updateAssetList();
                    showNotification('‚úÖ Escena cargada');
                } catch (error) {
                    console.error('Error cargando escena:', error);
                    showNotification('‚ùå Error al cargar escena');
                }
            };

            reader.readAsText(file);
        }

        // ============================================
        // INTEGRACI√ìN GOOGLE DRIVE (Parcial)
        // ============================================
        function connectGoogleDrive() {
            showNotification('üîó Conectando con Google Drive...');
            
            // Placeholder para OAuth2
            // En producci√≥n, esto requerir√≠a credenciales de Google Cloud
            setTimeout(() => {
                driveAccessToken = 'mock-token-' + Date.now();
                document.getElementById('drive-status').textContent = '‚úÖ Conectado';
                document.getElementById('drive-status').classList.remove('disconnected');
                document.getElementById('drive-controls').classList.remove('hidden');
                showNotification('‚úÖ Conectado a Google Drive');
            }, 1500);
        }

        async function saveSceneToDrive() {
            if (!driveAccessToken) {
                showNotification('‚ùå Con√©ctate primero a Drive');
                return;
            }

            showNotification('‚òÅÔ∏è Guardando en Drive...');
            
            const sceneData = {
                version: '24.0',
                timestamp: new Date().toISOString(),
                universes: universes.map(u => ({
                    id: u.id,
                    url: u.url,
                    type: u.type,
                    projection: u.projection,
                    scale: u.scale,
                    position: u.position,
                    rotation: u.rotation,
                    shaders: u.shaders,
                    videoSettings: u.videoSettings
                }))
            };

            // Placeholder - en producci√≥n usar√≠a la API de Drive
            console.log('Escena para Drive:', sceneData);
            setTimeout(() => {
                showNotification('‚úÖ Guardado en Drive (simulado)');
            }, 1500);
        }

        function loadSceneFromDrive() {
            if (!driveAccessToken) {
                showNotification('‚ùå Con√©ctate primero a Drive');
                return;
            }

            showNotification('‚òÅÔ∏è Esta funci√≥n requiere selector de archivos de Drive');
            // Placeholder - requiere Google Picker API
        }

        // ============================================
        // UTILIDADES
        // ============================================
        function detectAssetType(urlOrFilename) {
            const lower = urlOrFilename.toLowerCase();
            
            if (lower.includes('youtube.com') || lower.includes('youtu.be')) {
                return 'youtube';
            }
            
            if (lower.match(/\.(mp4|webm|ogg|mov)$/)) {
                return 'video';
            }
            
            if (lower.match(/\.(jpg|jpeg|png|webp|bmp)$/)) {
                return 'image';
            }
            
            if (lower.match(/\.gif$/)) {
                return 'gif';
            }
            
            if (lower.match(/\.(glb|gltf|obj|fbx)$/)) {
                return 'model';
            }
            
            return 'unknown';
        }

        function extractYouTubeId(url) {
            const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
            const match = url.match(regex);
            return match ? match[1] : null;
        }

        function showNotification(message) {
            const existing = document.querySelector('.notification');
            if (existing) existing.remove();

            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            document.body.appendChild(notif);

            setTimeout(() => notif.remove(), 3000);
        }

        // ============================================
        // INICIALIZACI√ìN
        // ============================================
        window.addEventListener('DOMContentLoaded', () => {
            initColorScheme();

            document.getElementById('scale-slider').addEventListener('input', (e) => {
                document.getElementById('scale-value').textContent = parseFloat(e.target.value).toFixed(1);
            });

            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const info = document.getElementById('file-info');
                    const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                    info.textContent = `üìÑ ${file.name} (${sizeMB} MB)`;
                }
            });

            // Bloquear proyecci√≥n para YouTube/modelos cuando se cambia
            document.getElementById('projection-type').addEventListener('change', (e) => {
                if (selectedUniverse && (selectedUniverse.type === 'youtube' || selectedUniverse.type === 'model')) {
                    e.target.value = 'plane';
                    showNotification('‚ö†Ô∏è Solo proyecci√≥n PLANO para este tipo');
                }
            });

            console.log('üé® MR Studio Diamond V24 FIXED - Listo');
        });
    </script>
</body>
</html>
