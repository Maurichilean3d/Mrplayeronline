<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>MR Studio Diamond v12.0 | Architect Edition</title>
  
  <script src="https://unpkg.com/omggif@1.0.10/omggif.js"></script>
  <script src="https://apis.google.com/js/api.js"></script>

  <style>
    * { box-sizing: border-box; user-select: none; }
    body { margin: 0; overflow: hidden; background: transparent; font-family: 'Segoe UI', system-ui, sans-serif; color: #eee; }
    #c { position: fixed; inset: 0; width: 100%; height: 100%; touch-action: none; z-index: 0; }
    
    .ui-panel { 
      position: fixed; left: 20px; top: 20px; width: 400px; max-height: 90vh; 
      background: rgba(12, 12, 16, 0.95); backdrop-filter: blur(20px); 
      border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 16px; 
      padding: 15px; overflow-y: auto; z-index: 100; 
      box-shadow: 0 20px 50px rgba(0,0,0,0.9);
      scrollbar-width: thin; scrollbar-color: #444 #111;
    }
    .ui-panel.minimized { transform: translateX(-450px); }
    
    #toggleUI {
        position: fixed; left: 20px; top: 20px; z-index: 101;
        width: 40px; height: 40px; border-radius: 50%; background: #6c5ce7;
        border: none; color: white; cursor: pointer; display: none;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5); font-weight: bold;
    }

    h2 { margin: 0 0 15px 0; font-size: 18px; color: #a29bfe; font-weight: 800; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px;}
    .sec-head { font-size: 10px; font-weight: 800; color: #74b9ff; margin: 15px 0 8px 0; text-transform: uppercase; letter-spacing: 1px; border-top: 1px solid rgba(255,255,255,0.05); padding-top: 10px; }
    
    .row { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; }
    label { font-size: 10px; flex: 1; color: #bbb; }
    input[type=range] { flex: 2; height: 4px; accent-color: #6c5ce7; cursor: pointer; background: #333; border-radius: 2px; }
    input[type=checkbox] { width: 14px; height: 14px; accent-color: #6c5ce7; cursor: pointer; }
    .val { width: 35px; text-align: right; font-size: 9px; color: #a29bfe; font-family: monospace; }
    
    .color-btn { width: 25px; height: 25px; border-radius: 50%; border: 2px solid #555; cursor: pointer; transition: 0.2s; }
    .color-btn:hover { transform: scale(1.1); border-color: white; }
    
    select, input[type=url] { width: 100%; background: #1e1e24; border: 1px solid #333; color: #eee; padding: 6px; border-radius: 6px; font-size: 11px; outline: none; }
    
    button { flex: 1; padding: 8px; border-radius: 6px; border: none; font-size: 10px; font-weight: 700; cursor: pointer; color: white; background: #2d3436; transition: 0.2s; }
    button.primary { background: #6c5ce7; }
    button.danger { background: rgba(214, 48, 49, 0.2); color: #ff7675; border: 1px solid #d63031; }
    button.media-btn { background: #0984e3; }
    button.drive-btn { background: #0F9D58; color: white; }
    
    .layer-list { max-height: 100px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 5px; margin-bottom: 10px; border: 1px solid #333; }
    .layer-item { padding: 6px; font-size: 10px; border-radius: 5px; cursor: pointer; display: flex; align-items: center; gap: 8px; margin-bottom: 2px; }
    .layer-item.active { background: rgba(108, 92, 231, 0.25); border-left: 3px solid #6c5ce7; }

    #vrBtn { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); padding: 14px 40px; background: #6c5ce7; color: white; border-radius: 50px; font-weight: 800; z-index: 1000; display: none; box-shadow: 0 0 30px rgba(108,92,231,0.6); border: 2px solid white; }
    .loader { position: fixed; inset: 0; background: #000; z-index: 5000; display: none; place-items: center; color: #a29bfe; font-weight: 900; letter-spacing: 2px; }
    
    #currentColorBox { width: 100%; height: 10px; border-radius: 4px; background: #00ff00; margin-bottom: 5px; border: 1px solid #555; }
  </style>
</head>
<body>

<canvas id="c"></canvas>
<div class="loader" id="loader">CARGANDO v12.0...</div>
<button id="toggleUI" onclick="toggleUIPanel()">‚ò∞</button>

<div class="ui-panel" id="ui">
  <h2>
      <span>üíé DIAMOND v12.0</span>
      <button style="width:auto; padding:4px 8px; background:transparent; font-size:16px;" onclick="toggleUIPanel()">√ó</button>
  </h2>

  <div class="sec-head">üìê Arquitectura & Unidades</div>
  <div class="row">
      <select id="unitSystem" onchange="updateUnits()">
          <option value="m">MKS - Metros</option>
          <option value="cm">MKS - Cent√≠metros</option>
          <option value="mm">MKS - Mil√≠metros</option>
          <option value="ft">Imperial - Pies</option>
          <option value="in">Imperial - Pulgadas</option>
      </select>
  </div>
  <div class="row">
      <label><input type="checkbox" id="showGrid" checked onchange="updateGrid()"> Mostrar Grilla</label>
      <label><input type="checkbox" id="showPlanes" onchange="updateGrid()"> Planos Aux</label>
  </div>
  
  <div class="sec-head">üîí Restricci√≥n de Escala (3D)</div>
  <div class="row" style="font-size:10px; color:#aaa;">
      <label><input type="checkbox" id="lockX"> Bloq X</label>
      <label><input type="checkbox" id="lockY"> Bloq Y</label>
      <label><input type="checkbox" id="lockZ"> Bloq Z</label>
  </div>

  <div class="sec-head">‚òÅÔ∏è Nube</div>
  <div class="row" id="authPanel"><button onclick="handleAuthClick()" class="drive-btn">üîë CONECTAR DRIVE</button></div>
  <div class="row" id="driveActions" style="display:none; gap:5px;">
      <button onclick="saveSceneToDrive()">üíæ GUARDAR</button>
      <button onclick="loadSceneFromDrive()">üìÇ CARGAR</button>
  </div>

  <div class="sec-head">üì• Contenido</div>
  <div class="row">
    <input type="url" id="webUrl" placeholder="URL Video/Imagen">
    <button class="primary" onclick="loadFromWeb()" style="width:50px;">ADD</button>
  </div>
  <button onclick="document.getElementById('fileInput').click()" style="width:100%; margin-top:5px;">üìÅ ABRIR LOCAL</button>
  <input type="file" id="fileInput" multiple style="display:none;">

  <div class="sec-head">Capas</div>
  <div id="layerList" class="layer-list"></div>

  <div id="editorUI" style="display:none;">
    <div class="sec-head">üé® Color & Luz</div>
    <div class="row"><label>Brillo</label><input type="range" id="brightness" min="-1" max="1" step="0.05" value="0"><span class="val" id="v_brightness">0</span></div>
    <div class="row"><label>Contraste</label><input type="range" id="contrast" min="0" max="3" step="0.1" value="1"><span class="val" id="v_contrast">1</span></div>
    <div class="row"><label>Saturaci√≥n</label><input type="range" id="saturation" min="0" max="3" step="0.1" value="1"><span class="val" id="v_saturation">1</span></div>
    
    <div class="sec-head">üõ†Ô∏è Chroma Key</div>
    <div class="row"><label><input type="checkbox" id="chromaToggle"> Activar Chroma</label></div>
    <div id="chromaPanel" style="display:none; background:rgba(0,0,0,0.3); padding:8px; border-radius:6px; margin-top:5px;">
        <div id="currentColorBox"></div>
        <div class="row" style="justify-content: space-around; margin-bottom:8px;">
            <div class="color-btn" style="background:#00ff00;" onclick="setChromaPreset(0,1,0)"></div>
            <div class="color-btn" style="background:#0000ff;" onclick="setChromaPreset(0,0,1)"></div>
            <div class="color-btn" style="background:#ff00ff;" onclick="setChromaPreset(1,0,1)"></div>
            <div class="color-btn" style="background:#000000;" onclick="setChromaPreset(0,0,0)"></div>
        </div>
        <div class="row"><label style="color:#f55">R</label><input type="range" id="keyR" min="0" max="1" step="0.01" value="0"></div>
        <div class="row"><label style="color:#5f5">G</label><input type="range" id="keyG" min="0" max="1" step="0.01" value="1"></div>
        <div class="row"><label style="color:#55f">B</label><input type="range" id="keyB" min="0" max="1" step="0.01" value="0"></div>
        <div class="row"><label>Rango</label><input type="range" id="k1sim" min="0" max="0.8" step="0.01"></div>
        <div class="row"><label>Suavizado</label><input type="range" id="k1smooth" min="0" max="0.4" step="0.01"></div>
    </div>
    
    <div class="row" style="margin-top:10px; gap:5px;">
        <button id="btnPlay" class="media-btn" onclick="mediaAction('play')">‚ñ∂</button>
        <button id="btnPause" class="media-btn" onclick="mediaAction('pause')">‚è∏</button>
        <button class="danger" onclick="deleteActive()">üóëÔ∏è BORRAR</button>
    </div>
  </div>

  <div class="sec-head">‚öôÔ∏è Config MR</div>
  <div class="row"><label><input type="checkbox" id="checkOcclusion"> Oclusi√≥n Real</label></div>
</div>

<button id="vrBtn">ENTRAR EN MR</button>

<script type="importmap">
{ "imports": {
  "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
} }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { TransformControls } from 'three/addons/controls/TransformControls.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

const CLIENT_ID = ''; const API_KEY = ''; const SCOPES = 'https://www.googleapis.com/auth/drive.file';

// ==========================================
// üåë OCLUSI√ìN SHADERS
// ==========================================
const depthVS = `#version 300 es
precision highp float; in vec2 aPos; out vec2 vUv; void main(){ vUv = aPos * 0.5 + 0.5; gl_Position = vec4(aPos, 0.0, 1.0); }`;
const depthFS = `#version 300 es
precision highp float; precision highp sampler2D; in vec2 vUv; uniform sampler2D uDepth; uniform float uRawToMeters; uniform mat4 uProj; out vec4 outColor;
float decodeRaw(vec4 la){ return (la.r * 255.0 * 256.0 + la.a * 255.0); }
void main(){ vec4 la = texture(uDepth, vUv); float zMeters = decodeRaw(la) * uRawToMeters; if(zMeters <= 0.0) discard;
  float z = -zMeters; float clipZ = uProj[2][2] * z + uProj[3][2]; float clipW = uProj[2][3] * z + uProj[3][3];
  gl_FragDepth = clamp((clipZ / clipW) * 0.5 + 0.5, 0.0, 1.0); outColor = vec4(0.0); }`;

// ==========================================
// üé® PRO SHADER
// ==========================================
const vShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
const fShader = `
uniform sampler2D map; uniform float uBrightness; uniform float uContrast; uniform float uSaturation;
uniform vec3 uTint; uniform float uEmissive; uniform float uBlur; uniform float uVignette; uniform float uNoise; uniform float uTime;
uniform float uOpacity; uniform bool chromaOn; uniform vec3 k1; uniform float sim1; uniform float smooth1;
varying vec2 vUv;
float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
void main() {
  vec4 texColor = texture2D(map, vUv);
  float alpha = texColor.a;
  if(chromaOn) { float d = distance(texColor.rgb, k1); float k = smoothstep(sim1, sim1 + smooth1, d); alpha *= k; }
  vec3 col = texColor.rgb; col *= uTint; col += uBrightness; col = (col - 0.5) * uContrast + 0.5;
  float gray = dot(col, vec3(0.299, 0.587, 0.114)); col = mix(vec3(gray), col, uSaturation); col += vec3(uEmissive * 0.5);
  if (uNoise > 0.0) { float grain = random(vUv + mod(uTime, 10.0)); col += (grain - 0.5) * uNoise; }
  alpha *= uOpacity; gl_FragColor = vec4(col, alpha); if(alpha < 0.01) discard; 
}`;

// ==========================================
// ‚öôÔ∏è SISTEMA PRINCIPAL
// ==========================================
let scene, camera, renderer, orbit, transformCtrl, xrSession, xrRefSpace;
let objects = [], activeId = null;
let clock = new THREE.Clock();
let xrGlBinding = null, depthProgram = null, depthVao = null, depthTex = null;
let occlusionEnabled = false;

// Variables XR & UI Espacial
let controller1, controller2, controllerGrip1, controllerGrip2, raycaster;
const tempMatrix = new THREE.Matrix4();
let measureLine, measureLabelSprite, measureLabelCanvas, measureLabelCtx;
let rotationRing;
let tutorialPlane;
let gridHelper, planeHelper;

// Estado de Unidades
let currentUnit = 'm'; // m, cm, mm, ft, in
let unitFactor = 1.0; // Factor para convertir metros a unidad visual

function init() {
  scene = new THREE.Scene();
  scene.add(new THREE.AmbientLight(0xffffff, 1));
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 500);
  camera.position.set(0, 1.6, 2);

  renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.xr.enabled = true;

  orbit = new OrbitControls(camera, renderer.domElement);
  orbit.target.set(0, 1.6, -2);
  orbit.enableDamping = true;

  transformCtrl = new TransformControls(camera, renderer.domElement);
  transformCtrl.addEventListener('dragging-changed', e => orbit.enabled = !e.value);
  scene.add(transformCtrl);
  
  // üìè ELEMENTOS DE MEDICI√ìN
  createMeasurementUI();
  createRotationRing();
  createTutorialUI();
  updateGrid(); // Crear grilla inicial

  setupXRControllers();
  setupVR();
  renderer.setAnimationLoop(animate);
  
  // UI Listeners
  document.getElementById('keyR').addEventListener('input', updateChromaManual);
  document.getElementById('keyG').addEventListener('input', updateChromaManual);
  document.getElementById('keyB').addEventListener('input', updateChromaManual);
  document.getElementById('chromaToggle').addEventListener('change', updateMaterial);
  
  document.querySelectorAll('input[type=range]').forEach(input => {
      if(input.id.startsWith('key')) return; 
      input.addEventListener('input', (e) => {
         const val = parseFloat(e.target.value);
         document.getElementById('v_' + e.target.id).innerText = val.toFixed(2);
         updateMaterialParam(e.target.id, val);
      });
  });
  
  window.setChromaPreset = (r, g, b) => {
      document.getElementById('keyR').value = r; document.getElementById('keyG').value = g; document.getElementById('keyB').value = b;
      updateChromaManual();
  };
  window.updateUnits = updateUnits;
  window.updateGrid = updateGrid;
}

// ==========================================
// üìè SISTEMA DE MEDICI√ìN Y UI "IRON MAN"
// ==========================================
function createMeasurementUI() {
    // L√≠nea de distancia (Gris suave, transparente)
    const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
    const mat = new THREE.LineBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.5 });
    measureLine = new THREE.Line(geo, mat);
    measureLine.frustumCulled = false;
    scene.add(measureLine);

    // Etiqueta de texto (Sprite)
    measureLabelCanvas = document.createElement('canvas');
    measureLabelCanvas.width = 256; measureLabelCanvas.height = 64;
    measureLabelCtx = measureLabelCanvas.getContext('2d');
    const tex = new THREE.CanvasTexture(measureLabelCanvas);
    const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    measureLabelSprite = new THREE.Sprite(spriteMat);
    measureLabelSprite.scale.set(0.5, 0.125, 1);
    measureLabelSprite.visible = false;
    scene.add(measureLabelSprite);
}

function updateMeasureLabel(distMeters) {
    let val = distMeters;
    let label = "m";
    // Conversi√≥n seg√∫n unidad seleccionada
    if(currentUnit === 'cm') { val *= 100; label = 'cm'; }
    if(currentUnit === 'mm') { val *= 1000; label = 'mm'; }
    if(currentUnit === 'ft') { val *= 3.28084; label = 'ft'; }
    if(currentUnit === 'in') { val *= 39.3701; label = 'in'; }

    measureLabelCtx.clearRect(0, 0, 256, 64);
    measureLabelCtx.fillStyle = "rgba(0, 0, 0, 0.6)";
    measureLabelCtx.fillRect(0, 0, 256, 64);
    measureLabelCtx.fillStyle = "#ffffff";
    measureLabelCtx.font = "bold 40px Arial";
    measureLabelCtx.textAlign = "center";
    measureLabelCtx.textBaseline = "middle";
    measureLabelCtx.fillText(val.toFixed(2) + " " + label, 128, 32);
    measureLabelSprite.material.map.needsUpdate = true;
}

function createRotationRing() {
    const geo = new THREE.RingGeometry(0.5, 0.52, 64);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
    rotationRing = new THREE.Mesh(geo, mat);
    rotationRing.rotation.x = -Math.PI / 2;
    scene.add(rotationRing);
}

function createTutorialUI() {
    const cvs = document.createElement('canvas'); cvs.width = 512; cvs.height = 512;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = "rgba(10, 10, 20, 0.9)"; ctx.fillRect(0,0,512,512);
    ctx.strokeStyle = "#6c5ce7"; ctx.lineWidth = 10; ctx.strokeRect(0,0,512,512);
    ctx.fillStyle = "#fff"; ctx.font = "bold 30px Arial"; ctx.textAlign = "center";
    
    const lines = [
        "CONTROLES ARQUITECTO",
        "--------------------",
        "MANO DERECHA (Grip):",
        "üïπÔ∏è Stick Y: Acercar / Alejar",
        "üïπÔ∏è Stick X: Rotar Objeto",
        "",
        "MANO IZQUIERDA (Grip):",
        "üïπÔ∏è Stick Y: Escalar Objeto",
        "--------------------",
        "üî´ Gatillo: Seleccionar"
    ];
    lines.forEach((l, i) => ctx.fillText(l, 256, 100 + (i * 40)));
    
    const tex = new THREE.CanvasTexture(cvs);
    const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
    tutorialPlane = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), mat);
    tutorialPlane.visible = false;
    // Se adjunta al controllerGrip2 (Izquierda) en setupControllers
}

// ==========================================
// üìê GRILLA Y UNIDADES
// ==========================================
function updateUnits() {
    currentUnit = document.getElementById('unitSystem').value;
    updateGrid();
}

function updateGrid() {
    if(gridHelper) scene.remove(gridHelper);
    if(planeHelper) scene.remove(planeHelper);
    
    if(!document.getElementById('showGrid').checked) return;

    let size = 10; let divs = 10; let color = 0x888888;
    
    // Ajustar tama√±o de grilla seg√∫n unidad
    if(currentUnit === 'ft' || currentUnit === 'in') {
        size = 3.048; // ~10 pies (3 metros aprox)
        divs = 10;    // 1 pie por cuadro
        color = 0x6c5ce7; 
    } else {
        size = 10;    // 10 metros
        divs = 10;    // 1 metro por cuadro
        color = 0x00ff00;
    }

    gridHelper = new THREE.GridHelper(size, divs, color, 0x444444);
    scene.add(gridHelper);

    if(document.getElementById('showPlanes').checked) {
        planeHelper = new THREE.GridHelper(size, divs, 0xff0000, 0x220000);
        planeHelper.rotation.x = Math.PI / 2;
        scene.add(planeHelper);
    }
}

// ==========================================
// üéÆ CONTROLES XR AVANZADOS (ARCHITECT LOGIC)
// ==========================================
function setupXRControllers() {
    controller1 = renderer.xr.getController(0); // DERECHA
    controller1.addEventListener('selectstart', onSelectStart);
    scene.add(controller1);

    controller2 = renderer.xr.getController(1); // IZQUIERDA
    controller2.addEventListener('selectstart', onSelectStart);
    // Listener para bot√≥n Y (Menu) - Suele ser button 4 o 5
    controller2.addEventListener('connected', (e) => {
        e.data.gamepad.onbuttondown = (btn) => {
            if(btn.button === 4 || btn.button === 5) toggleTutorial();
        };
    });
    scene.add(controller2);

    const controllerModelFactory = new XRControllerModelFactory();
    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
    scene.add(controllerGrip1);

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
    // Adjuntar tutorial a la mano izquierda
    if(tutorialPlane) {
        tutorialPlane.position.set(0, 0.2, 0); // Flotando sobre el mando
        controllerGrip2.add(tutorialPlane);
    }
    scene.add(controllerGrip2);

    const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
    const line = new THREE.Line(geometry); line.name = 'line'; line.scale.z = 5;
    controller1.add(line.clone()); controller2.add(line.clone());

    raycaster = new THREE.Raycaster();
}

function toggleTutorial() {
    if(tutorialPlane) tutorialPlane.visible = !tutorialPlane.visible;
}

function handleArchitectControls() {
    const session = renderer.xr.getSession();
    if (!session || !activeId) return;
    const obj = objects.find(o => o.id === activeId);
    if (!obj) return;

    // Reseteamos UI si no hay acci√≥n
    measureLine.visible = false;
    measureLabelSprite.visible = false;
    rotationRing.material.opacity = 0;

    for (const source of session.inputSources) {
        if (!source.gamepad) continue;
        const gp = source.gamepad;
        const gripPressed = gp.buttons[1].pressed; // Bot√≥n lateral
        const axisX = gp.axes[2];
        const axisY = gp.axes[3];

        // --- MANO DERECHA (MOVIMIENTO & ROTACI√ìN) ---
        if (source.handedness === 'right' && gripPressed) {
            
            // 1. ACERCAR / ALEJAR (Stick Y) - Rayo Tractor
            if (Math.abs(axisY) > 0.1) {
                // Vector direcci√≥n C√°mara -> Objeto
                const camPos = new THREE.Vector3();
                const objPos = new THREE.Vector3();
                camera.getWorldPosition(camPos);
                obj.mesh.getWorldPosition(objPos);
                
                const dir = new THREE.Vector3().subVectors(objPos, camPos).normalize();
                const speed = axisY * -0.05; // Invertir eje
                obj.mesh.position.addScaledVector(dir, speed);

                // UI MEDICI√ìN
                measureLine.geometry.setFromPoints([camPos, objPos]);
                measureLine.visible = true;
                
                const dist = camPos.distanceTo(objPos);
                measureLabelSprite.position.copy(camPos).lerp(objPos, 0.5);
                measureLabelSprite.position.y += 0.1;
                measureLabelSprite.lookAt(camPos);
                measureLabelSprite.visible = true;
                updateMeasureLabel(dist);
            }

            // 2. ROTACI√ìN Y (Stick X)
            if (Math.abs(axisX) > 0.1) {
                obj.mesh.rotation.y -= axisX * 0.05;
                // UI ROTACI√ìN
                rotationRing.position.copy(obj.mesh.position);
                rotationRing.material.opacity = 0.8;
            }
        }

        // --- MANO IZQUIERDA (ESCALA) ---
        if (source.handedness === 'left' && gripPressed) {
            if (Math.abs(axisY) > 0.1) {
                const scaleSpeed = 1 - (axisY * 0.02);
                
                const lockX = document.getElementById('lockX').checked;
                const lockY = document.getElementById('lockY').checked;
                const lockZ = document.getElementById('lockZ').checked;

                if(!lockX) obj.mesh.scale.x *= scaleSpeed;
                if(!lockY) obj.mesh.scale.y *= scaleSpeed;
                if(!lockZ) obj.mesh.scale.z *= scaleSpeed;

                // Clamp
                obj.mesh.scale.clampScalar(0.01, 20);
                
                // Actualizar UI Slider
                if(!lockX) {
                    document.getElementById('scale').value = obj.mesh.scale.x;
                    document.getElementById('v_scale').innerText = obj.mesh.scale.x.toFixed(2);
                }
            }
        }
    }
}

function onSelectStart(event) {
    const controller = event.target;
    tempMatrix.identity().extractRotation(controller.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
    const meshGroup = objects.map(o => o.mesh);
    const intersections = raycaster.intersectObjects(meshGroup, false);
    if (intersections.length > 0) {
        const object = intersections[0].object;
        if(object.userData && object.userData.id) selectObject(object.userData.id);
    }
}

// ==========================================
// üì¶ ASSET LOADER
// ==========================================
async function addAsset(url, type, name, isGif = false, isRestore = false) {
  if(!isRestore) toggleLoader(true);
  let tex, mesh, gifData = null, video = null;
  let newObj = null;

  try {
    if (isGif) {
      const resp = await fetch(url);
      const buf = await resp.arrayBuffer();
      const reader = new window.Omggif.GifReader(new Uint8Array(buf));
      const cvs = document.createElement('canvas'); cvs.width = reader.width; cvs.height = reader.height;
      const ctx = cvs.getContext('2d'); const imgData = ctx.createImageData(cvs.width, cvs.height);
      tex = new THREE.CanvasTexture(cvs); tex.colorSpace = THREE.SRGBColorSpace;
      gifData = { reader, ctx, imgData, tex, frame: 0, nextTime: 0, playing: true };
    } else if (type === 'video') {
      video = document.createElement('video'); video.src = url; video.loop = true; video.muted = true; video.crossOrigin = "anonymous"; video.playsInline = true;
      await video.play(); tex = new THREE.VideoTexture(video); tex.colorSpace = THREE.SRGBColorSpace;
    } else {
      tex = await new THREE.TextureLoader().loadAsync(url); tex.colorSpace = THREE.SRGBColorSpace;
    }

    const aspect = video ? video.videoWidth/video.videoHeight : (tex.image ? tex.image.width/tex.image.height : 1.77);

    const mat = new THREE.ShaderMaterial({
      uniforms: { 
        map: { value: tex }, uAspect: { value: aspect }, uTime: { value: 0 },
        uBrightness: { value: 0.0 }, uContrast: { value: 1.0 }, uSaturation: { value: 1.0 },
        uTint: { value: new THREE.Vector3(1,1,1) }, uEmissive: { value: 0.0 }, uOpacity: { value: 1.0 },
        uBlur: { value: 0.0 }, uVignette: { value: 0.0 }, uNoise: { value: 0.0 },
        chromaOn: { value: false }, k1: { value: new THREE.Color(0,1,0) }, sim1: { value: 0.4 }, smooth1: { value: 0.08 }
      },
      vertexShader: vShader, fragmentShader: fShader, transparent: true, side: THREE.DoubleSide, depthWrite: false
    });

    const geometry = new THREE.PlaneGeometry(aspect * 2, 2); 
    mesh = new THREE.Mesh(geometry, mat);
    mesh.position.set(0, 1.6, -2);
    
    const objId = Math.random().toString(36).substr(2,9);
    mesh.userData.id = objId;
    
    newObj = { id: objId, name, mesh, video, gifData, type, billboard: false, originalAspect: aspect, sourceUrl: url };
    
    objects.push(newObj);
    scene.add(mesh);
    if(!isRestore) selectObject(newObj.id);
  } catch (e) { 
    console.error(e); if(!isRestore) alert("Error cargando.");
  }
  if(!isRestore) toggleLoader(false);
  return newObj;
}

// ==========================================
// üéÆ UPDATE LOOP
// ==========================================
function animate(time, frame) {
  const elapsedTime = clock.getElapsedTime();
  orbit.update();
  
  // LOGICA DE CONTROLES AVANZADOS
  handleArchitectControls();
  
  objects.forEach(obj => {
      if(obj.billboard && obj.mesh) obj.mesh.lookAt(camera.position.x, obj.mesh.position.y, camera.position.z);
      if(obj.mesh && obj.mesh.material.uniforms.uTime) obj.mesh.material.uniforms.uTime.value = elapsedTime;
      if (obj.gifData && obj.gifData.playing) {
        const g = obj.gifData;
        if (performance.now() > g.nextTime) {
          g.reader.decodeAndBlitFrameRGBA(g.frame, g.imgData.data); g.ctx.putImageData(g.imgData, 0, 0);
          g.tex.needsUpdate = true; g.nextTime = performance.now() + (g.reader.frameInfo(g.frame).delay * 10 || 100);
          g.frame = (g.frame + 1) % g.reader.numFrames();
        }
      }
  });

  if (frame && occlusionEnabled && xrGlBinding) {
    const pose = frame.getViewerPose(xrRefSpace);
    if (pose) {
      const gl = renderer.getContext();
      gl.colorMask(false, false, false, false);
      for (const view of pose.views) {
        const depthInfo = xrGlBinding.getDepthInformation(view);
        if (depthInfo) {
           gl.bindTexture(gl.TEXTURE_2D, depthTex);
           gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE_ALPHA, depthInfo.width, depthInfo.height, 0, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE, depthInfo.data);
           gl.useProgram(depthProgram);
           gl.uniform1f(gl.getUniformLocation(depthProgram, 'uRawToMeters'), depthInfo.rawValueToMeters);
           gl.uniformMatrix4fv(gl.getUniformLocation(depthProgram, 'uProj'), false, view.projectionMatrix);
           gl.bindVertexArray(depthVao);
           gl.drawArrays(gl.TRIANGLES, 0, 6);
        }
      }
      gl.colorMask(true, true, true, true);
    }
  }

  renderer.render(scene, camera);
}

// ==========================================
// üîå SETUP VR
// ==========================================
function setupVR() {
  if (navigator.xr) {
    navigator.xr.isSessionSupported('immersive-ar').then(ok => {
      if (ok) {
        document.getElementById('vrBtn').style.display='block'; 
        document.getElementById('vrBtn').onclick = async () => {
          occlusionEnabled = document.getElementById('checkOcclusion').checked;
          const sessionInit = { requiredFeatures: ['local-floor'], optionalFeatures: ['dom-overlay'], domOverlay: { root: document.body } };
          if(occlusionEnabled) { sessionInit.optionalFeatures.push('depth-sensing'); sessionInit.depthSensing = { usagePreference: ['cpu-optimized'], dataFormatPreference: ['luminance-alpha'] }; }
          xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);
          renderer.xr.setSession(xrSession);
          xrRefSpace = await xrSession.requestReferenceSpace('local-floor');
          if (occlusionEnabled) initDepthOcclusion(xrSession);
        };
      }
    });
  }
}

function initDepthOcclusion(session) {
  const gl = renderer.getContext(); xrGlBinding = new XRWebGLBinding(session, gl);
  const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, depthVS); gl.compileShader(vs);
  const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, depthFS); gl.compileShader(fs);
  depthProgram = gl.createProgram(); gl.attachShader(depthProgram, vs); gl.attachShader(depthProgram, fs); gl.linkProgram(depthProgram);
  depthVao = gl.createVertexArray(); gl.bindVertexArray(depthVao);
  const vbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
  const loc = gl.getAttribLocation(depthProgram, 'aPos'); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
  depthTex = gl.createTexture();
}

function updateMaterialParam(id, val) {
    const obj = objects.find(o => o.id === activeId); if(!obj) return;
    const u = obj.mesh.material.uniforms;
    if(id === 'scale') obj.mesh.scale.setScalar(val); else if(id === 'posY') obj.mesh.position.y = val; else if(id === 'posZ') obj.mesh.position.z = val; else if(id === 'rotY') obj.mesh.rotation.y = val;
    else if(id === 'brightness') u.uBrightness.value = val; else if(id === 'contrast') u.uContrast.value = val; else if(id === 'saturation') u.uSaturation.value = val;
    else if(id === 'emissive') u.uEmissive.value = val; else if(id === 'opacity') u.uOpacity.value = val; else if(id === 'blur') u.uBlur.value = val; else if(id === 'vignette') u.uVignette.value = val; else if(id === 'noise') u.uNoise.value = val; else if(id === 'k1sim') u.sim1.value = val; else if(id === 'k1smooth') u.smooth1.value = val;
    if(id === 'uRed' || id === 'uGreen' || id === 'uBlue') u.uTint.value.set(document.getElementById('uRed').value, document.getElementById('uGreen').value, document.getElementById('uBlue').value);
}

function updateChromaManual() {
    const obj = objects.find(o => o.id === activeId); if(!obj) return;
    const r = parseFloat(document.getElementById('keyR').value);
    const g = parseFloat(document.getElementById('keyG').value);
    const b = parseFloat(document.getElementById('keyB').value);
    obj.mesh.material.uniforms.k1.value.setRGB(r, g, b);
    const hex = new THREE.Color(r, g, b).getHexString();
    document.getElementById('currentColorBox').style.backgroundColor = '#' + hex;
}

function updateMaterial() {
    const obj = objects.find(o => o.id === activeId); if(!obj) return;
    const u = obj.mesh.material.uniforms;
    u.chromaOn.value = document.getElementById('chromaToggle').checked;
    document.getElementById('chromaPanel').style.display = u.chromaOn.value ? 'block' : 'none';
    const currentK1 = u.k1.value; document.getElementById('keyR').value = currentK1.r; document.getElementById('keyG').value = currentK1.g; document.getElementById('keyB').value = currentK1.b; updateChromaManual();
}

function selectObject(id) {
  activeId = id; const obj = objects.find(o => o.id === id); if (!obj) return;
  transformCtrl.attach(obj.mesh); document.getElementById('editorUI').style.display = 'block'; updateLayers();
  const u = obj.mesh.material.uniforms;
  const setVal = (domId, val) => { const el = document.getElementById(domId); if(el) { el.value = val; const disp = document.getElementById('v_' + domId); if(disp) disp.innerText = (typeof val === 'number') ? val.toFixed(2) : val; } };
  setVal('scale', obj.mesh.scale.x); setVal('posY', obj.mesh.position.y); setVal('posZ', obj.mesh.position.z); setVal('rotY', obj.mesh.rotation.y);
  setVal('brightness', u.uBrightness.value); setVal('contrast', u.uContrast.value); setVal('saturation', u.uSaturation.value);
  setVal('emissive', u.uEmissive.value); setVal('opacity', u.uOpacity.value); setVal('blur', u.uBlur.value); setVal('vignette', u.uVignette.value); setVal('noise', u.uNoise.value);
  document.getElementById('uRed').value = u.uTint.value.x; document.getElementById('uGreen').value = u.uTint.value.y; document.getElementById('uBlue').value = u.uTint.value.z;
  document.getElementById('checkBillboard').checked = obj.billboard; document.getElementById('chromaToggle').checked = u.chromaOn.value; setVal('k1sim', u.sim1.value); setVal('k1smooth', u.smooth1.value);
  document.getElementById('chromaPanel').style.display = u.chromaOn.value ? 'block' : 'none';
  const k1 = u.k1.value; document.getElementById('keyR').value = k1.r; document.getElementById('keyG').value = k1.g; document.getElementById('keyB').value = k1.b; updateChromaManual();
}

// PERSISTENCE & UTILS
window.saveSceneToDrive = () => { /* ... (Same logic as v11) ... */ };
window.loadSceneFromDrive = () => { /* ... (Same logic as v11) ... */ };
window.handleAuthClick = () => { /* ... (Same logic as v11) ... */ };
window.loadFromWeb = () => { const u = document.getElementById('webUrl').value; if(u) addAsset(u, u.match(/\.(mp4|webm)/i)?'video':'image', 'Web Asset', u.includes('.gif')); };
document.getElementById('fileInput').onchange = (e) => { for(let f of e.target.files) addAsset(URL.createObjectURL(f), f.type.includes('video')?'video':'image', f.name, f.name.includes('.gif')); };
window.deleteActive = () => { const i = objects.findIndex(o => o.id===activeId); if(i>-1) { scene.remove(objects[i].mesh); objects.splice(i,1); transformCtrl.detach(); document.getElementById('editorUI').style.display='none'; updateLayers(); } };
window.mediaAction = (a) => { const o = objects.find(x=>x.id===activeId); if(o && o.video) { if(a=='play') o.video.play(); if(a=='pause') o.video.pause(); } };
function updateLayers() { const l=document.getElementById('layerList'); l.innerHTML=''; objects.forEach(o => { const d=document.createElement('div'); d.className=`layer-item ${o.id===activeId?'active':''}`; d.innerText=(o.type=='video'?'üé¨ ':'üñºÔ∏è ')+o.name.slice(0,15); d.onclick=()=>selectObject(o.id); l.appendChild(d); }); }
window.toggleUIPanel = () => { document.getElementById('ui').classList.toggle('minimized'); document.getElementById('toggleUI').style.display = document.getElementById('ui').classList.contains('minimized') ? 'block' : 'none'; };
window.updateProjection = () => { const o = objects.find(x=>x.id===activeId); if(!o) return; const m = document.getElementById('projSelect').value; scene.remove(o.mesh); let g; if(m=='360') { g=new THREE.SphereGeometry(100,64,32); o.mesh.material.side=THREE.BackSide; } else if(m=='orb') { g=new THREE.SphereGeometry(1.5,64,32); o.mesh.material.side=THREE.FrontSide; } else if(m=='curved') { g=new THREE.CylinderGeometry(5,5,2,32,1,true,3.8,1.8); o.mesh.scale.set(-1,1,1); o.mesh.material.side=THREE.DoubleSide; } else { g=new THREE.PlaneGeometry(o.originalAspect*2, 2); o.mesh.material.side=THREE.DoubleSide; } o.mesh.geometry=g; scene.add(o.mesh); transformCtrl.attach(o.mesh); };
function toggleLoader(s) { document.getElementById('loader').style.display=s?'grid':'none'; }

init();
</script>
</body>
</html>
