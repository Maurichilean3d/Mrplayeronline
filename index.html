<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>MR Studio Diamond v30.0 | Ultimate Architect</title>
  
  <script src="https://unpkg.com/omggif@1.0.10/omggif.js"></script>
  <script src="https://apis.google.com/js/api.js"></script>

  <style>
    /* =========================================
       üé® UI SYSTEM: AMBER GLASS (Arquitectura)
    ========================================= */
    :root {
        --main: #ffaa00; /* Amber Neon */
        --bg: rgba(15, 15, 20, 0.9);
        --glass: rgba(255, 170, 0, 0.1);
        --border: 1px solid rgba(255, 170, 0, 0.3);
        --font: 'Segoe UI', system-ui, sans-serif;
    }

    * { box-sizing: border-box; user-select: none; font-family: var(--font); }
    body { margin: 0; overflow: hidden; background: #111; color: #eee; }
    #c { position: fixed; inset: 0; width: 100%; height: 100%; touch-action: none; z-index: 0; }

    /* PANEL PRINCIPAL */
    .ui-panel { 
      position: fixed; left: 20px; top: 20px; width: 360px; max-height: 95vh; 
      background: var(--bg); backdrop-filter: blur(20px); border: var(--border); 
      border-radius: 16px; padding: 15px; z-index: 100; 
      box-shadow: 0 10px 40px rgba(0,0,0,0.8);
      scrollbar-width: thin; scrollbar-color: var(--main) transparent;
      transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
      display: flex; flex-direction: column; gap: 10px;
    }
    .minimized { transform: translateX(-420px); }

    /* TIPOGRAF√çA & ELEMENTOS */
    h2 { margin: 0; font-size: 14px; color: var(--main); text-transform: uppercase; letter-spacing: 2px; border-bottom: var(--border); padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
    .sec-head { font-size: 10px; font-weight: 800; color: #888; text-transform: uppercase; margin-top: 10px; letter-spacing: 1px; }
    
    .row { display: flex; align-items: center; gap: 8px; font-size: 11px; margin-bottom: 4px; }
    label { flex: 1; color: #ccc; cursor: pointer; white-space: nowrap; }
    
    /* INPUTS */
    input[type=range] { flex: 2; height: 4px; accent-color: var(--main); background: #333; border-radius: 2px; -webkit-appearance: none; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: var(--main); border-radius: 50%; cursor: pointer; }
    input[type=checkbox] { accent-color: var(--main); width: 14px; height: 14px; cursor: pointer; }
    input[type=text], input[type=url] { width: 100%; background: #222; border: 1px solid #444; color: #fff; padding: 6px; border-radius: 4px; font-size: 11px; outline: none; }
    select { width: 100%; background: #222; color: #fff; border: 1px solid #444; padding: 5px; border-radius: 4px; outline: none; }
    .val { width: 35px; text-align: right; color: var(--main); font-family: monospace; font-weight: bold; }

    /* BOTONES */
    button { flex: 1; padding: 8px; border-radius: 6px; border: none; font-weight: 700; cursor: pointer; color: #000; background: var(--main); transition: 0.2s; font-size: 10px; text-transform: uppercase; }
    button:hover { filter: brightness(1.2); }
    button:active { transform: scale(0.96); }
    button.secondary { background: rgba(255,255,255,0.1); color: #fff; border: var(--border); }
    button.danger { background: #ff4757; color: white; }
    button.drive { background: #2ecc71; color: white; }

    /* LISTA DE CAPAS (DRAG & DROP) */
    .layer-list { max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 5px; border: 1px solid #333; }
    .layer-item { 
      padding: 6px 8px; font-size: 11px; border-radius: 4px; margin-bottom: 2px; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: 0.2s; background: rgba(255,255,255,0.05); 
    }
    .layer-item:hover { background: rgba(255, 170, 0, 0.15); }
    .layer-item.active { background: rgba(255, 170, 0, 0.25); border-left: 3px solid var(--main); }
    .layer-drag-handle { cursor: grab; color: #666; font-size: 14px; }
    .layer-vis { cursor: pointer; width: 14px; text-align: center; }

    /* COLOR PICKER CUSTOM */
    .color-presets { display: flex; justify-content: space-around; margin: 8px 0; }
    .color-dot { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; border: 2px solid #444; transition: 0.2s; }
    .color-dot:hover { transform: scale(1.2); border-color: #fff; }
    #currentColorBox { width: 100%; height: 8px; border-radius: 4px; background: #0f0; margin-bottom: 8px; }

    /* BOTONES FLOTANTES */
    #toggleUI { position: fixed; left: 20px; top: 20px; z-index: 101; width: 40px; height: 40px; border-radius: 50%; background: #222; border: 2px solid var(--main); color: var(--main); font-size: 18px; cursor: pointer; display: none; align-items: center; justify-content: center; }
    #vrBtn { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); padding: 12px 40px; background: var(--main); color: #000; border-radius: 30px; font-weight: 800; z-index: 1000; display: none; box-shadow: 0 0 20px rgba(255, 170, 0, 0.6); border: 2px solid #fff; letter-spacing: 1px; }
    .loader { position: fixed; inset: 0; background: #000; z-index: 5000; display: none; place-items: center; flex-direction: column; gap: 10px; color: var(--main); font-weight: 900; letter-spacing: 2px; }
    
    /* MODOS XR */
    #xrEnvControls { display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #444; }
  </style>
</head>
<body>

<canvas id="c"></canvas>
<div class="loader" id="loader"><div>CARGANDO MOTOR...</div></div>
<button id="toggleUI" onclick="togglePanel()">‚ò∞</button>

<div class="ui-panel" id="ui">
  <h2>DIAMOND v30.0 <span onclick="togglePanel()" style="cursor:pointer;">√ó</span></h2>

  <div class="row" style="gap:5px;">
    <button class="drive" onclick="handleAuthClick()">‚òÅÔ∏è DRIVE</button>
    <button class="secondary" onclick="saveScene()">üíæ SAVE</button>
    <button class="secondary" onclick="document.getElementById('jsonInput').click()">üìÇ LOAD</button>
    <input type="file" id="jsonInput" accept=".json" style="display:none;" onchange="loadSceneLocal(this)">
  </div>

  <div class="sec-head">üì• Importar (Foto, Video, 3D)</div>
  <div class="row">
    <input type="url" id="webUrl" placeholder="Pegar URL...">
    <button onclick="loadFromWeb()" style="flex:0.4;">+</button>
  </div>
  <button class="secondary" onclick="document.getElementById('fileInput').click()" style="width:100%;">üìÅ ABRIR ARCHIVO LOCAL</button>
  <input type="file" id="fileInput" multiple style="display:none;" onchange="handleFileSelect(this)">

  <div class="sec-head">Capas (Arrastrar para ordenar)</div>
  <div id="layerList" class="layer-list"></div>

  <div id="editorUI" style="display:none;">
    
    <div class="sec-head">üìê Transformaci√≥n</div>
    <div class="row"><label>Escala</label><input type="range" id="scale" min="0.01" max="10" step="0.01"><span class="val" id="v_scale">1.0</span></div>
    <div class="row"><label>Altura Y</label><input type="range" id="posY" min="-5" max="5" step="0.1"><span class="val" id="v_posY">0.0</span></div>
    <div class="row"><label>Rotaci√≥n Y</label><input type="range" id="rotY" min="0" max="6.28" step="0.1"><span class="val" id="v_rotY">0.0</span></div>
    <div class="row"><label><input type="checkbox" id="checkBillboard"> Billboard (Mirar a c√°m)</label></div>

    <div id="mediaControls">
        <div class="sec-head">üé® Edici√≥n de Imagen</div>
        <div class="row"><label>Brillo</label><input type="range" id="brightness" min="-1" max="1" step="0.05"><span class="val" id="v_brightness">0</span></div>
        <div class="row"><label>Contraste</label><input type="range" id="contrast" min="0" max="3" step="0.1"><span class="val" id="v_contrast">1</span></div>
        <div class="row"><label>Saturaci√≥n</label><input type="range" id="saturation" min="0" max="3" step="0.1"><span class="val" id="v_saturation">1</span></div>
        <div class="row"><label>Gamma</label><input type="range" id="gamma" min="0.1" max="3" step="0.1"><span class="val" id="v_gamma">1</span></div>
        <div class="row"><label>Opacidad</label><input type="range" id="opacity" min="0" max="1" step="0.01"><span class="val" id="v_opacity">1</span></div>

        <div class="sec-head">üõ†Ô∏è Chroma Key Ultra</div>
        <div class="row"><label><input type="checkbox" id="chromaToggle"> Activar</label> <label><input type="checkbox" id="chromaInvert"> Invertir</label></div>
        <div id="chromaPanel" style="display:none; background:rgba(255,255,255,0.05); padding:8px; border-radius:6px;">
            <div id="currentColorBox"></div>
            <div class="color-presets">
                <div class="color-dot" style="background:#00ff00;" onclick="setChroma(0,1,0)"></div>
                <div class="color-dot" style="background:#0000ff;" onclick="setChroma(0,0,1)"></div>
                <div class="color-dot" style="background:#000000;" onclick="setChroma(0,0,0)"></div>
                <div class="color-dot" style="background:#ffffff;" onclick="setChroma(1,1,1)"></div>
                <div class="color-dot" style="background:#808080;" onclick="setChroma(0.5,0.5,0.5)"></div>
            </div>
            <div class="row"><label>Similitud</label><input type="range" id="sim" min="0" max="0.8" step="0.001"><span class="val" id="v_sim">0.4</span></div>
            <div class="row"><label>Suavizado</label><input type="range" id="smooth" min="0" max="0.4" step="0.001"><span class="val" id="v_smooth">0.1</span></div>
            <div class="row"><label>Despill</label><input type="range" id="despill" min="0" max="1" step="0.01"><span class="val" id="v_despill">0.5</span></div>
            <input type="hidden" id="keyR" value="0"><input type="hidden" id="keyG" value="1"><input type="hidden" id="keyB" value="0">
        </div>
        
        <div class="row" style="margin-top:10px;">
            <button onclick="mediaAction('play')">‚ñ∂ PLAY</button>
            <button onclick="mediaAction('pause')">‚è∏ PAUSE</button>
            <button onclick="mediaAction('mute')">üîá MUTE</button>
        </div>
    </div>

    <div class="sec-head">üåê Proyecci√≥n</div>
    <select id="projSelect" onchange="updateProjection()">
        <option value="plane">Plano 2D</option>
        <option value="curved">Pantalla Curva</option>
        <option value="360">Esfera 360¬∞</option>
        <option value="180">Domo 180¬∞</option>
        <option value="cube">Cubo</option>
        <option value="sphere">Esfera (Externa)</option>
    </select>

    <button class="danger" onclick="deleteActive()" style="width:100%; margin-top:15px;">üóëÔ∏è ELIMINAR CAPA</button>
  </div>

  <div class="sec-head">‚öôÔ∏è Escena & Arquitectura</div>
  <div class="row">
      <select id="unitSystem" onchange="updateUnits()">
          <option value="m">Metros (m)</option>
          <option value="cm">Cent√≠metros (cm)</option>
          <option value="ft">Pies (ft)</option>
      </select>
  </div>
  <div class="row"><label><input type="checkbox" id="showGrid" checked onchange="updateGrid()"> Holo Grid</label></div>
  <div class="row"><label><input type="checkbox" id="showDims" checked> Cotas (Dimensiones)</label></div>
  <div class="row"><label><input type="checkbox" id="checkOcclusion"> Oclusi√≥n (Depth API)</label></div>
  
  <div class="sec-head">üï∂Ô∏è Entorno VR</div>
  <select id="vrEnv" onchange="updateEnv()">
      <option value="passthrough">Passthrough (MR)</option>
      <option value="dark">Estudio Oscuro</option>
      <option value="white">Estudio Blanco</option>
      <option value="grid">Cyber Grid</option>
  </select>
</div>

<button id="vrBtn">INICIAR EXPERIENCIA MR</button>

<script type="importmap">
{ "imports": {
  "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
} }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { TransformControls } from 'three/addons/controls/TransformControls.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

// ==========================================
// üîê CREDENCIALES GOOGLE (Usuario debe llenar)
// ==========================================
const CLIENT_ID = ''; 
const API_KEY = ''; 
const SCOPES = 'https://www.googleapis.com/auth/drive.file';

// ==========================================
// üé® SHADERS (Universal: Foto/Video/Chroma/Grading)
// ==========================================
const vShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
const fShader = `
uniform sampler2D map; 
uniform float uBrightness, uContrast, uSaturation, uGamma, uOpacity;
uniform bool chromaOn, chromaInvert; 
uniform vec3 k1; 
uniform float sim1, smooth1, despill;
varying vec2 vUv;

vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y); float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

void main() {
  vec4 tex = texture2D(map, vUv);
  vec3 col = tex.rgb;
  float alpha = tex.a * uOpacity;

  if(chromaOn) {
      vec3 hsv = rgb2hsv(col); vec3 kHsv = rgb2hsv(k1);
      float hueDist = abs(hsv.x - kHsv.x); if (hueDist > 0.5) hueDist = 1.0 - hueDist;
      float dist = sqrt(pow(hueDist * 2.0, 2.0) + pow(abs(hsv.y - kHsv.y), 2.0) + pow(abs(hsv.z - kHsv.z) * 0.5, 2.0));
      float mask = smoothstep(sim1, sim1 + smooth1, dist);
      
      if(!chromaInvert) {
          alpha *= mask;
          // DESPILL AVANZADO
          if(mask < 0.95 && despill > 0.0) {
             if(k1.g > k1.r && k1.g > k1.b) col.g = mix(col.g, max(col.r, col.b), (1.0 - mask) * despill);
             else if(k1.b > k1.r && k1.b > k1.g) col.b = mix(col.b, max(col.r, col.g), (1.0 - mask) * despill);
          }
      } else { 
          alpha = (1.0 - mask) * uOpacity; 
          col = vec3(1.0); // M√°scara blanca para visualizaci√≥n
      }
  }

  // COLOR GRADING
  col += uBrightness; 
  col = (col - 0.5) * uContrast + 0.5;
  float gray = dot(col, vec3(0.299, 0.587, 0.114)); 
  col = mix(vec3(gray), col, uSaturation);
  col = pow(max(col, 0.0), vec3(1.0 / uGamma));

  gl_FragColor = vec4(col, alpha); 
  if(alpha < 0.01) discard; 
}`;

// OCLUSI√ìN (DEPTH API)
const depthVS = `#version 300 es
in vec2 aPos; out vec2 vUv; void main(){ vUv = aPos * 0.5 + 0.5; gl_Position = vec4(aPos, 0.0, 1.0); }`;
const depthFS = `#version 300 es
precision highp float; precision highp sampler2D; in vec2 vUv; uniform sampler2D uDepth; uniform float uRawToMeters; uniform mat4 uProj; out vec4 outColor;
float decode(vec4 la){ return (la.r * 255.0 * 256.0 + la.a * 255.0); }
void main(){ 
  float z = -decode(texture(uDepth, vUv)) * uRawToMeters; if(z >= 0.0) discard;
  float clipZ = uProj[2][2] * z + uProj[3][2]; float clipW = uProj[2][3] * z + uProj[3][3];
  gl_FragDepth = clamp((clipZ / clipW) * 0.5 + 0.5, 0.0, 1.0); outColor = vec4(0.0); 
}`;

// ==========================================
// ‚öôÔ∏è VARIABLES DEL SISTEMA
// ==========================================
let scene, camera, renderer, orbit, transformCtrl, xrSession, xrRefSpace;
let objects = [], activeId = null, clock = new THREE.Clock();
let xrGlBinding, depthProgram, depthVao, depthTex, occlusionEnabled = false;
let controller1, controller2, controllerGrip1, controllerGrip2, raycaster, tempMatrix = new THREE.Matrix4();

// UI Ingenier√≠a
let engGroup, coordLabels = { x:null, y:null, z:null }, dimLabels = { w:null, h:null, d:null };
let currentUnit = 'm';
let activeEnv = 'passthrough';

function init() {
  const container = document.getElementById('c');
  scene = new THREE.Scene(); 
  scene.add(new THREE.AmbientLight(0xffffff, 1.5));
  const dirLight = new THREE.DirectionalLight(0xffffff, 2); dirLight.position.set(5,10,5); scene.add(dirLight);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 500); 
  camera.position.set(0, 1.6, 2);

  renderer = new THREE.WebGLRenderer({ canvas: container, antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight); 
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.xr.enabled = true; 
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  orbit = new OrbitControls(camera, renderer.domElement);
  
  transformCtrl = new TransformControls(camera, renderer.domElement);
  transformCtrl.addEventListener('dragging-changed', e => orbit.enabled = !e.value);
  transformCtrl.addEventListener('change', () => { if(activeId) updateEngineeringVisuals(); });
  scene.add(transformCtrl);
  
  initEngineeringUI();
  updateGrid(); 
  setupXRControllers();
  setupVR();
  
  renderer.setAnimationLoop(animate);
  window.addEventListener('resize', onResize);
  
  initUIEvents();
}

// ==========================================
// üïπÔ∏è INTERACCI√ìN & L√ìGICA
// ==========================================
function initUIEvents() {
    // Sliders de Material
    const params = ['brightness','contrast','saturation','gamma','opacity','k1sim','k1smooth','despill'];
    params.forEach(p => {
        document.getElementById(p).addEventListener('input', e => updateObjSetting(p, parseFloat(e.target.value)));
    });
    
    // Transform Sliders
    ['scale','posY','rotY'].forEach(p => {
        document.getElementById(p).addEventListener('input', e => {
            const v = parseFloat(e.target.value);
            document.getElementById('v_'+p).innerText = v.toFixed(2);
            updateObjTransform(p, v);
        });
    });

    // Checkboxes
    document.getElementById('chromaToggle').addEventListener('change', e => updateObjSetting('chromaOn', e.target.checked));
    document.getElementById('chromaInvert').addEventListener('change', e => updateObjSetting('chromaInvert', e.target.checked));
    document.getElementById('checkBillboard').addEventListener('change', e => updateObjSetting('billboard', e.target.checked));
    
    // Globales
    window.togglePanel = () => document.getElementById('ui').classList.toggle('minimized');
    window.setChroma = (r,g,b) => { updateObjSetting('k1', new THREE.Vector3(r,g,b)); };
    window.updateUnits = () => { currentUnit = document.getElementById('unitSystem').value; updateGrid(); updateEngineeringVisuals(); };
    window.updateEnv = () => { activeEnv = document.getElementById('vrEnv').value; if(activeEnv!=='passthrough') scene.background = new THREE.Color(activeEnv==='white'?0xffffff:0x111111); else scene.background = null; };
    window.updateGrid = updateGrid;
}

function updateObjSetting(key, val) {
    if(!activeId) return;
    const obj = objects.find(o => o.id === activeId);
    if(!obj) return;
    
    // Actualizar datos del objeto
    if(key === 'k1') {
        obj.settings.k1 = val;
        document.getElementById('currentColorBox').style.backgroundColor = `rgb(${val.x*255},${val.y*255},${val.z*255})`;
    } else {
        obj.settings[key] = val;
    }

    // Aplicar a material si existe
    if(obj.mesh.material && obj.mesh.material.uniforms) {
        const u = obj.mesh.material.uniforms;
        if(key === 'brightness') u.uBrightness.value = val;
        if(key === 'contrast') u.uContrast.value = val;
        if(key === 'saturation') u.uSaturation.value = val;
        if(key === 'gamma') u.uGamma.value = val;
        if(key === 'opacity') u.uOpacity.value = val;
        if(key === 'chromaOn') { u.chromaOn.value = val; document.getElementById('chromaPanel').style.display = val?'block':'none'; }
        if(key === 'chromaInvert') u.chromaInvert.value = val;
        if(key === 'k1sim') u.sim1.value = val;
        if(key === 'k1smooth') u.smooth1.value = val;
        if(key === 'despill') u.despill.value = val;
        if(key === 'k1') u.k1.value.set(val.x, val.y, val.z);
    }
    
    // Texto
    const lbl = document.getElementById('v_'+key);
    if(lbl && typeof val === 'number') lbl.innerText = val.toFixed(2);
}

function updateObjTransform(key, val) {
    if(!activeId) return;
    const obj = objects.find(o => o.id === activeId);
    if(key === 'scale') obj.mesh.scale.setScalar(val);
    if(key === 'posY') obj.mesh.position.y = val;
    if(key === 'rotY') obj.mesh.rotation.y = val;
    updateEngineeringVisuals();
}

function selectObject(id) {
    activeId = id;
    const obj = objects.find(o => o.id === id);
    if(!obj) { transformCtrl.detach(); document.getElementById('editorUI').style.display='none'; return; }

    transformCtrl.attach(obj.mesh);
    document.getElementById('editorUI').style.display = 'block';
    
    // Sincronizar UI con Objeto
    const s = obj.settings;
    const setUI = (id, v) => {
        const el = document.getElementById(id);
        if(el.type === 'checkbox') el.checked = v;
        else { el.value = v; const l = document.getElementById('v_'+id); if(l) l.innerText = v.toFixed(2); }
    };

    setUI('scale', obj.mesh.scale.x);
    setUI('posY', obj.mesh.position.y);
    setUI('rotY', obj.mesh.rotation.y);
    setUI('checkBillboard', s.billboard);
    
    // Si tiene material shader
    if(obj.mesh.material.uniforms) {
        document.getElementById('mediaControls').style.display = 'block';
        setUI('brightness', s.brightness);
        setUI('contrast', s.contrast);
        setUI('saturation', s.saturation);
        setUI('gamma', s.gamma);
        setUI('opacity', s.opacity);
        setUI('chromaToggle', s.chromaOn);
        setUI('chromaInvert', s.chromaInvert);
        setUI('k1sim', s.k1sim);
        setUI('k1smooth', s.k1smooth);
        setUI('despill', s.despill);
        document.getElementById('chromaPanel').style.display = s.chromaOn ? 'block' : 'none';
        document.getElementById('currentColorBox').style.backgroundColor = `rgb(${s.k1.x*255},${s.k1.y*255},${s.k1.z*255})`;
    } else {
        document.getElementById('mediaControls').style.display = 'none'; // Es modelo 3D
    }
    
    updateLayersUI();
    updateEngineeringVisuals();
}

// ==========================================
// üèóÔ∏è INGENIER√çA UI (COTAS DIN√ÅMICAS)
// ==========================================
function initEngineeringUI() {
    engGroup = new THREE.Group(); scene.add(engGroup);
    
    const lineMat = new THREE.LineDashedMaterial({ color: 0xffaa00, dashSize: 0.1, gapSize: 0.05, opacity:0.8, transparent:true });
    const lineY = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]), lineMat);
    lineY.name = 'lineY'; engGroup.add(lineY);
    
    const frameGeo = new THREE.RingGeometry(0.48, 0.5, 4); frameGeo.rotateZ(Math.PI/4);
    const frameMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent:true, opacity:0.8, side:THREE.DoubleSide, depthWrite:false });
    const shadow = new THREE.Mesh(frameGeo, frameMat);
    shadow.rotation.x = -Math.PI/2; shadow.name = 'shadowPlane'; engGroup.add(shadow);

    coordLabels.x = createLabel(); coordLabels.y = createLabel(); coordLabels.z = createLabel();
    engGroup.add(coordLabels.x); engGroup.add(coordLabels.y); engGroup.add(coordLabels.z);
    dimLabels.w = createLabel(); dimLabels.h = createLabel(); 
    engGroup.add(dimLabels.w); engGroup.add(dimLabels.h);
    engGroup.visible = false;
}

function createLabel() {
    const cvs = document.createElement('canvas'); cvs.width=256; cvs.height=64;
    const tex = new THREE.CanvasTexture(cvs);
    const mat = new THREE.SpriteMaterial({ map:tex, transparent:true, depthTest:false });
    const s = new THREE.Sprite(mat); s.scale.set(0.3, 0.075, 1);
    s.userData = { cvs, ctx: cvs.getContext('2d'), tex, last: "" };
    return s;
}

function updateLabel(sprite, text, isDim=false) {
    if(sprite.userData.last === text) return;
    sprite.userData.last = text;
    const { ctx, tex } = sprite.userData;
    ctx.clearRect(0,0,256,64);
    ctx.fillStyle = "rgba(15, 15, 20, 0.8)"; ctx.roundRect(5,5,246,54,12); ctx.fill();
    ctx.strokeStyle = isDim ? "#ffff00" : "#ffaa00"; ctx.lineWidth=3; ctx.stroke();
    ctx.fillStyle = "#fff"; ctx.font = "bold 32px monospace"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText(text, 128, 32); tex.needsUpdate = true;
}

function formatUnit(val) {
    if(currentUnit==='cm') return (val*100).toFixed(0)+'cm';
    if(currentUnit==='ft') return (val*3.28).toFixed(2)+'ft';
    return val.toFixed(2)+'m';
}

function updateEngineeringVisuals() {
    if(!activeId || !document.getElementById('showDims').checked) { engGroup.visible = false; return; }
    const obj = objects.find(o => o.id === activeId); if(!obj) return;
    engGroup.visible = true;

    const P = obj.mesh.position; const S = obj.mesh.scale; const R = obj.mesh.rotation;
    // Dimensiones aproximadas (Para planos es exacto, para 3D es BoundingBox)
    let w = 1, h = 1;
    if(obj.type === 'model') {
        const box = new THREE.Box3().setFromObject(obj.mesh);
        const sz = new THREE.Vector3(); box.getSize(sz);
        w = sz.x; h = sz.y;
    } else {
        w = (obj.originalAspect || 1) * S.x; h = 1 * S.y;
    }

    // Linea Y
    const lineY = engGroup.getObjectByName('lineY');
    lineY.geometry.setFromPoints([P, new THREE.Vector3(P.x, 0, P.z)]); lineY.computeLineDistances();

    // Sombra
    const shadow = engGroup.getObjectByName('shadowPlane');
    shadow.position.set(P.x, 0.005, P.z); shadow.rotation.set(-Math.PI/2, 0, R.y);
    shadow.scale.set(Math.max(w, 0.5)*1.1, Math.max(w, 0.5)*1.1, 1);

    // Coordenadas
    if(document.getElementById('showCoords').checked) {
        coordLabels.x.visible=true; coordLabels.y.visible=true; coordLabels.z.visible=true;
        coordLabels.y.position.set(P.x+0.3, P.y/2, P.z); updateLabel(coordLabels.y, "H: "+formatUnit(P.y));
        coordLabels.x.position.set(P.x, 0.1, P.z+0.3); updateLabel(coordLabels.x, "X: "+formatUnit(P.x));
        coordLabels.z.position.set(P.x+0.3, 0.1, P.z); updateLabel(coordLabels.z, "Z: "+formatUnit(P.z));
    } else {
        coordLabels.x.visible=false; coordLabels.y.visible=false; coordLabels.z.visible=false;
    }

    // Cotas
    dimLabels.w.visible=true; dimLabels.h.visible=true;
    dimLabels.w.position.copy(P).add(new THREE.Vector3(0, h/2+0.2, 0)); updateLabel(dimLabels.w, "W: "+formatUnit(w), true);
    dimLabels.h.position.copy(P).add(new THREE.Vector3(w/2+0.2, 0, 0)); updateLabel(dimLabels.h, "H: "+formatUnit(h), true);
}

// ==========================================
// üì¶ LOADERS & ASSET MANAGEMENT
// ==========================================
async function loadAsset(url, type, name, isGif=false, fromSave=null) {
    toggleLoader(true);
    try {
        let mesh, tex, video, gifData;
        let aspect = 1.77;

        if (type === 'model') {
            const ext = name.split('.').pop().toLowerCase();
            let model;
            if(ext === 'glb' || ext === 'gltf') model = (await new GLTFLoader().loadAsync(url)).scene;
            else if(ext === 'fbx') model = await new FBXLoader().loadAsync(url);
            else if(ext === 'obj') model = await new OBJLoader().loadAsync(url);
            
            // Auto-scale
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3()).length();
            const scalar = size > 0 ? 1 / size : 1;
            model.scale.setScalar(scalar);
            mesh = model;
        } 
        else {
            // 2D Media (Video/Photo/Gif)
            if(isGif) {
                const buf = await (await fetch(url)).arrayBuffer();
                const r = new window.Omggif.GifReader(new Uint8Array(buf));
                const cvs = document.createElement('canvas'); cvs.width=r.width; cvs.height=r.height;
                const ctx = cvs.getContext('2d'); const dat = ctx.createImageData(r.width, r.height);
                tex = new THREE.CanvasTexture(cvs); tex.colorSpace = THREE.SRGBColorSpace;
                gifData = { r, ctx, dat, tex, f:0, nextTime:0, playing:true };
                aspect = r.width / r.height;
            } else if(type === 'video') {
                video = document.createElement('video'); video.src = url; video.crossOrigin = "anonymous";
                video.loop = true; video.muted = true; video.playsInline = true; await video.play();
                tex = new THREE.VideoTexture(video); tex.colorSpace = THREE.SRGBColorSpace;
                aspect = video.videoWidth / video.videoHeight;
            } else {
                tex = await new THREE.TextureLoader().loadAsync(url); tex.colorSpace = THREE.SRGBColorSpace;
                aspect = tex.image.width / tex.image.height;
            }

            const geo = new THREE.PlaneGeometry(aspect, 1);
            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    map: { value: tex },
                    uBrightness: { value: 0 }, uContrast: { value: 1 }, uSaturation: { value: 1 }, uGamma: { value: 1 }, uOpacity: { value: 1 },
                    chromaOn: { value: false }, chromaInvert: { value: false }, k1: { value: new THREE.Vector3(0,1,0) },
                    sim1: { value: 0.4 }, smooth1: { value: 0.08 }, despill: { value: 0.5 }
                },
                vertexShader: vShader, fragmentShader: fShader, transparent: true, side: THREE.DoubleSide
            });
            mesh = new THREE.Mesh(geo, mat);
        }

        const id = fromSave ? fromSave.id : Math.random().toString(36).substr(2, 9);
        mesh.userData.id = id;
        
        // Initial State
        if (fromSave) {
            mesh.position.fromArray(fromSave.pos);
            mesh.rotation.fromArray(fromSave.rot);
            mesh.scale.fromArray(fromSave.scl);
            // Restaurar Settings
            if(type!=='model') {
                const s = fromSave.settings;
                const u = mesh.material.uniforms;
                u.uBrightness.value = s.brightness; u.uContrast.value = s.contrast; 
                u.uSaturation.value = s.saturation; u.uGamma.value = s.gamma; u.uOpacity.value = s.opacity;
                u.chromaOn.value = s.chromaOn; u.chromaInvert.value = s.chromaInvert;
                u.k1.value.set(s.k1.x, s.k1.y, s.k1.z);
                u.sim1.value = s.k1sim; u.smooth1.value = s.k1smooth; u.despill.value = s.despill;
            }
        } else {
            mesh.position.set(0, 1.6, -2);
        }

        scene.add(mesh);
        
        const objData = { 
            id, name, type, mesh, tex, video, gifData, originalAspect: aspect, sourceUrl: url,
            settings: fromSave ? fromSave.settings : {
                brightness:0, contrast:1, saturation:1, gamma:1, opacity:1,
                chromaOn:false, chromaInvert:false, k1:{x:0,y:1,z:0}, k1sim:0.4, k1smooth:0.08, despill:0.5,
                billboard:false
            }
        };
        
        objects.push(objData);
        updateLayersUI();
        selectObject(id);

    } catch(e) { console.error(e); alert("Error cargando asset"); }
    toggleLoader(false);
}

// Wrappers
window.loadFromWeb = () => { const u = document.getElementById('webUrl').value; if(u) loadAsset(u, u.match(/\.(mp4|webm)/i)?'video':'image', 'Web Asset'); };
window.handleFileSelect = (input) => { 
    for(let f of input.files) {
        const url = URL.createObjectURL(f);
        let type = 'image';
        if(f.type.includes('video')) type = 'video';
        if(f.name.match(/\.(glb|gltf|fbx|obj)$/i)) type = 'model';
        loadAsset(url, type, f.name, f.name.includes('.gif'));
    }
    input.value = '';
};

// ==========================================
// üñ±Ô∏è CAPAS (LAYER MANAGER)
// ==========================================
function updateLayersUI() {
    const list = document.getElementById('layerList'); list.innerHTML = '';
    objects.slice().reverse().forEach(o => { // Reverse para ver arriba el ultimo
        const div = document.createElement('div');
        div.className = `layer-item ${o.id === activeId ? 'active' : ''}`;
        div.draggable = true;
        div.innerHTML = `
            <span style="font-size:14px;">${o.type==='model'?'üì¶':(o.type==='video'?'üé¨':'üñºÔ∏è')}</span>
            <span style="flex:1; overflow:hidden; text-overflow:ellipsis;">${o.name}</span>
            <span onclick="toggleVis('${o.id}')" style="cursor:pointer;">üëÅÔ∏è</span>
        `;
        div.onclick = (e) => { if(e.target.tagName!=='SPAN') selectObject(o.id); };
        
        // Drag Logic Simple
        div.ondragstart = (e) => { e.dataTransfer.setData('text/plain', o.id); };
        div.ondragover = (e) => { e.preventDefault(); };
        div.ondrop = (e) => {
            e.preventDefault();
            const draggedId = e.dataTransfer.getData('text/plain');
            if(draggedId === o.id) return;
            // Reordenar array objects
            const fromIdx = objects.findIndex(x=>x.id===draggedId);
            const toIdx = objects.findIndex(x=>x.id===o.id);
            const item = objects.splice(fromIdx, 1)[0];
            objects.splice(toIdx, 0, item);
            updateLayersUI();
        };
        list.appendChild(div);
    });
}
window.toggleVis = (id) => { const o = objects.find(x=>x.id===id); if(o) { o.mesh.visible = !o.mesh.visible; } };
window.deleteActive = () => {
    const idx = objects.findIndex(x=>x.id===activeId);
    if(idx > -1) {
        scene.remove(objects[idx].mesh);
        objects.splice(idx, 1);
        activeId = null;
        transformCtrl.detach();
        document.getElementById('editorUI').style.display = 'none';
        engGroup.visible = false;
        updateLayersUI();
    }
};

// ==========================================
// üéÆ CONTROLES XR (STABLE POLLING)
// ==========================================
function setupXRControllers() {
    controller1 = renderer.xr.getController(0); 
    controller1.addEventListener('selectstart', onSelect); 
    controller1.addEventListener('squeezestart', onGripStart); controller1.addEventListener('squeezeend', onGripEnd);
    scene.add(controller1);

    controller2 = renderer.xr.getController(1); 
    controller2.addEventListener('selectstart', onSelect);
    scene.add(controller2);

    const fac = new XRControllerModelFactory();
    controllerGrip1 = renderer.xr.getControllerGrip(0); controllerGrip1.add(fac.createControllerModel(controllerGrip1)); scene.add(controllerGrip1);
    controllerGrip2 = renderer.xr.getControllerGrip(1); controllerGrip2.add(fac.createControllerModel(controllerGrip2)); scene.add(controllerGrip2);

    const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]);
    const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffaa00 })); 
    controller1.add(line.clone()); controller2.add(line.clone());
    raycaster = new THREE.Raycaster();
}

function handleXRInput() {
    const s = renderer.xr.getSession();
    if(!s || !activeId) return;
    const obj = objects.find(o => o.id === activeId);
    if(!obj) return;

    for(const src of s.inputSources) {
        const gp = src.gamepad;
        if(!gp) continue;
        const grip = gp.buttons[1]?.pressed;
        const axes = gp.axes;
        
        // Fallback axes
        const ax = (axes.length>=4) ? axes[2] : (axes[0]||0);
        const ay = (axes.length>=4) ? axes[3] : (axes[1]||0);
        
        if(!Number.isFinite(ax) || !Number.isFinite(ay)) continue;

        if(src.handedness === 'left' && grip) {
            // IZQ: Escala (X) / Altura (Y)
            if(Math.abs(ax) > 0.1) {
                let sF = 1 + (ax * 0.02);
                obj.mesh.scale.multiplyScalar(sF);
                obj.mesh.scale.clampScalar(0.01, 50);
            }
            if(Math.abs(ay) > 0.1) {
                obj.mesh.position.y -= ay * 0.02;
                if(obj.mesh.position.y < 0) obj.mesh.position.y = 0;
            }
        }
        if(src.handedness === 'right' && grip) {
            // DER: Rotaci√≥n (X) / Mover Plano (Y - Rayo tractor)
            if(Math.abs(ax) > 0.1) obj.mesh.rotation.y -= ax * 0.05;
            if(Math.abs(ay) > 0.1) {
                const dir = new THREE.Vector3().subVectors(obj.mesh.position, camera.position).normalize();
                dir.y = 0;
                obj.mesh.position.addScaledVector(dir, ay * -0.05);
            }
        }
    }
}

// Grip Select Logic
function onGripStart(e) {
    const c = e.target;
    const hits = getIntersections(c);
    if(hits.length > 0) {
        const o = hits[0].object;
        if(o.userData.id) selectObject(o.userData.id); // Auto-Select on Grip
        c.attach(o); c.userData.selected = o;
    }
}
function onGripEnd(e) { const c = e.target; if(c.userData.selected) { scene.attach(c.userData.selected); c.userData.selected = null; } }
function onSelect(e) { const hits = getIntersections(e.target); if(hits.length>0 && hits[0].object.userData.id) selectObject(hits[0].object.userData.id); }
function getIntersections(c) { 
    tempMatrix.identity().extractRotation(c.matrixWorld); 
    raycaster.ray.origin.setFromMatrixPosition(c.matrixWorld); 
    raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix); 
    return raycaster.intersectObjects(objects.map(o=>o.mesh), false); 
}

// ==========================================
// üîÅ ANIMATE
// ==========================================
function animate(time, frame) {
    orbit.update();
    const dt = clock.getElapsedTime();
    handleXRInput();
    updateEngineeringVisuals();

    // GIFs
    objects.forEach(o => {
        if(o.billboard) o.mesh.lookAt(camera.position.x, o.mesh.position.y, camera.position.z);
        if(o.gifData && o.gifData.playing && performance.now() > o.gifData.nextTime) {
            const g=o.gifData; g.r.decodeAndBlitFrameRGBA(g.f, g.dat.data); g.ctx.putImageData(g.dat,0,0);
            g.tex.needsUpdate=true; g.nextTime=performance.now()+100; g.f=(g.f+1)%g.r.numFrames();
        }
    });

    // OCLUSI√ìN
    if(frame && occlusionEnabled && xrGlBinding) {
        const pose = frame.getViewerPose(xrRefSpace);
        if(pose) {
            const gl = renderer.getContext();
            gl.colorMask(false,false,false,false);
            for(const view of pose.views) {
                const dInfo = xrGlBinding.getDepthInformation(view);
                if(dInfo) {
                    gl.bindTexture(gl.TEXTURE_2D, depthTex);
                    gl.texImage2D(gl.TEXTURE_2D,0,gl.LUMINANCE_ALPHA, dInfo.width, dInfo.height, 0, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE, dInfo.data);
                    gl.useProgram(depthProgram);
                    gl.uniform1f(gl.getUniformLocation(depthProgram,'uRawToMeters'), dInfo.rawValueToMeters);
                    gl.uniformMatrix4fv(gl.getUniformLocation(depthProgram,'uProj'), false, view.projectionMatrix);
                    gl.bindVertexArray(depthVao); gl.drawArrays(gl.TRIANGLES,0,6);
                }
            }
            gl.colorMask(true,true,true,true);
        }
    }
    renderer.render(scene, camera);
}

// ==========================================
// üíæ SAVE / LOAD (JSON)
// ==========================================
window.saveScene = () => {
    const data = objects.map(o => ({
        url: o.sourceUrl, type: o.type, name: o.name,
        pos: o.mesh.position.toArray(), rot: o.mesh.rotation.toArray(), scl: o.mesh.scale.toArray(),
        settings: o.settings
    }));
    const blob = new Blob([JSON.stringify(data)], {type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'scene.json'; a.click();
};

window.loadSceneLocal = (input) => {
    const reader = new FileReader();
    reader.onload = (e) => {
        const data = JSON.parse(e.target.result);
        objects.forEach(o => scene.remove(o.mesh)); objects = [];
        data.forEach(d => loadAsset(d.url, d.type, d.name, d.url.includes('.gif'), d));
    };
    reader.readAsText(input.files[0]);
};

// Drive Logic Stubs (Requires API Setup)
window.handleAuthClick = () => { gapi.auth2.getAuthInstance().signIn(); };
window.saveSceneToDrive = () => { /* Implementar subida Multipart */ alert("Configurar API Key primero"); };
window.loadSceneFromDrive = () => { /* Implementar Picker */ alert("Configurar API Key primero"); };

// ==========================================
// üîß HELPERS & INIT
// ==========================================
window.toggleLoader = (s) => document.getElementById('loader').style.display = s?'flex':'none';
window.updateProjection = () => {
    const o = objects.find(x=>x.id===activeId); if(!o || o.type==='model') return;
    const m = document.getElementById('projSelect').value;
    scene.remove(o.mesh);
    let geo;
    if(m==='plane') geo = new THREE.PlaneGeometry(o.originalAspect, 1);
    else if(m==='360') geo = new THREE.SphereGeometry(100, 64, 32);
    else if(m==='180') geo = new THREE.SphereGeometry(100, 64, 32, 0, Math.PI);
    else if(m==='cube') geo = new THREE.BoxGeometry(100, 100, 100);
    
    // Recrear mesh con nuevo geo pero mismo material
    const newMesh = new THREE.Mesh(geo, o.mesh.material);
    if(m!=='plane') newMesh.material.side = THREE.BackSide; else newMesh.material.side = THREE.DoubleSide;
    
    newMesh.position.copy(o.mesh.position); newMesh.rotation.copy(o.mesh.rotation); newMesh.scale.copy(o.mesh.scale);
    newMesh.userData = o.mesh.userData;
    o.mesh = newMesh; scene.add(newMesh); selectObject(o.id);
};

function onResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

// VR Start
function setupVR() {
  if(navigator.xr) navigator.xr.isSessionSupported('immersive-ar').then(ok => {
      if(ok) {
          const btn = document.getElementById('vrBtn'); btn.style.display='block';
          btn.onclick = async () => {
              occlusionEnabled = document.getElementById('checkOcclusion').checked;
              const feat = ['local-floor']; const opt = ['dom-overlay'];
              if(occlusionEnabled) opt.push('depth-sensing');
              xrSession = await navigator.xr.requestSession('immersive-ar', { requiredFeatures:feat, optionalFeatures:opt, domOverlay:{root:document.body}, depthSensing: { usagePreference:['cpu-optimized'], dataFormatPreference:['luminance-alpha'] } });
              renderer.xr.setSession(xrSession); xrRefSpace = await xrSession.requestReferenceSpace('local-floor');
              if(occlusionEnabled) {
                  const gl = renderer.getContext(); xrGlBinding = new XRWebGLBinding(xrSession, gl);
                  const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, depthVS); gl.compileShader(vs);
                  const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, depthFS); gl.compileShader(fs);
                  depthProgram = gl.createProgram(); gl.attachShader(depthProgram, vs); gl.attachShader(depthProgram, fs); gl.linkProgram(depthProgram);
                  depthVao = gl.createVertexArray(); gl.bindVertexArray(depthVao);
                  const vbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
                  depthTex = gl.createTexture();
              }
          };
      }
  });
}

// Iniciar
init();
</script>
</body>
</html>
