<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>MR Studio Diamond v6.9 (Fixed + Ellipsoid)</title>
  <script src="https://unpkg.com/omggif@1.0.10/omggif.js"></script>
  <style>
    /* ESTILOS UI - Mantenidos de la versi√≥n Pro */
    * { box-sizing: border-box; user-select: none; }
    body { margin: 0; overflow: hidden; background: transparent; font-family: 'Segoe UI', system-ui, sans-serif; color: #eee; }
    #c { position: fixed; inset: 0; width: 100%; height: 100%; touch-action: none; z-index: 0; }
    
    .ui-panel { position: fixed; left: 20px; top: 20px; width: 400px; max-height: 95vh; background: rgba(10, 10, 14, 0.96); backdrop-filter: blur(25px); border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 18px; padding: 20px; overflow-y: auto; z-index: 100; box-shadow: 0 25px 60px rgba(0,0,0,0.85); transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); scrollbar-width: thin; scrollbar-color: #6c5ce7 transparent; }
    .ui-panel.hidden { transform: translateX(-460px); }
    
    h2 { margin: 0 0 18px 0; font-size: 20px; color: #a29bfe; font-weight: 900; text-transform: uppercase; letter-spacing: 1.5px; border-bottom: 2px solid rgba(108, 92, 231, 0.3); padding-bottom: 10px; background: linear-gradient(135deg, #6c5ce7, #a29bfe); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; display: flex; justify-content: space-between; align-items: center; }
    .ver-badge { font-size: 10px; background: #55efc4; color: #000; padding: 2px 6px; border-radius: 4px; vertical-align: middle; font-weight: 800; }

    .sec-head { font-size: 11px; font-weight: 800; color: #b2b9c6; margin: 18px 0 10px 0; text-transform: uppercase; letter-spacing: 0.8px; display: flex; align-items: center; gap: 8px; }
    .row { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
    label { font-size: 12px; flex: 1; color: #d1d5db; white-space: nowrap; font-weight: 500; }
    
    /* FIX: Slider optimizado 0.1 a 5 */
    input[type=range] { flex: 2; height: 6px; background: #2a2d35; border-radius: 3px; accent-color: #6c5ce7; cursor: pointer; }
    
    .val { width: 50px; text-align: right; font-size: 11px; font-family: 'Consolas', monospace; color: #a29bfe; font-weight: 600; }
    select, input[type=file], input[type=text] { width: 100%; background: #1e1e24; border: 1px solid #444; color: #eee; padding: 10px; border-radius: 10px; font-size: 11px; outline: none; cursor: pointer; transition: 0.2s; }
    select:hover, input[type=file]:hover { border-color: #6c5ce7; }
    
    button { flex: 1; padding: 12px; border-radius: 10px; border: none; font-size: 11px; font-weight: 800; cursor: pointer; color: white; background: #2a2d35; transition: all 0.25s; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; justify-content: center; gap: 5px; }
    button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); filter: brightness(1.2); }
    button.primary { background: linear-gradient(135deg, #6c5ce7, #a29bfe); box-shadow: 0 5px 20px rgba(108,92,231,0.4); }
    button.danger { background: rgba(255, 71, 87, 0.15); border: 1px solid rgba(255, 71, 87, 0.4); color: #ff7675; }
    button.warn { background: rgba(253, 203, 110, 0.15); border: 1px solid rgba(253, 203, 110, 0.4); color: #ffeaa7; }
    button.info { background: rgba(116, 185, 255, 0.15); border: 1px solid rgba(116, 185, 255, 0.4); color: #74b9ff; }

    .layer-list { max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.4); border-radius: 10px; padding: 6px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05); }
    .layer-item { padding: 10px; font-size: 12px; border-radius: 8px; cursor: move; display: flex; align-items: center; gap: 12px; margin-bottom: 5px; border: 1px solid transparent; transition: all 0.2s; background: rgba(255,255,255,0.02); }
    .layer-item:hover { background: rgba(108, 92, 231, 0.15); border-color: rgba(108, 92, 231, 0.3); }
    .layer-item.active { background: rgba(108, 92, 231, 0.3); border-color: rgba(108, 92, 231, 0.6); color: white; box-shadow: 0 0 15px rgba(108, 92, 231, 0.3); }
    .layer-item.dragging { opacity: 0.5; transform: scale(0.95); }

    .toggle-ui { position: fixed; bottom: 30px; right: 30px; width: 56px; height: 56px; background: linear-gradient(135deg, #1e1e24, #2a2d35); border-radius: 50%; display: grid; place-items: center; font-size: 22px; border: 2px solid #6c5ce7; z-index: 200; cursor: pointer; box-shadow: 0 8px 25px rgba(108, 92, 231, 0.5); transition: 0.3s; }
    .toggle-ui:hover { transform: scale(1.1); }

    #vrBtn { position: fixed; bottom: 35px; left: 50%; transform: translateX(-50%); padding: 16px 50px; background: linear-gradient(135deg, #6c5ce7, #0984e3); color: white; border-radius: 60px; border: none; font-weight: 900; cursor: pointer; z-index: 1000; display: none; font-size: 14px; box-shadow: 0 0 35px rgba(108,92,231,0.7); animation: pulse 2s infinite; text-transform: uppercase; letter-spacing: 2px; }
    @keyframes pulse { 0% {box-shadow: 0 0 25px rgba(108,92,231,0.7);} 50% {box-shadow: 0 0 45px rgba(108,92,231,0.9);} 100% {box-shadow: 0 0 25px rgba(108,92,231,0.7);} }

    #modeBadge{ position: fixed; top: 20px; right: 20px; z-index: 1200; background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.15); padding: 12px 16px; border-radius: 14px; font-size: 13px; display:flex; gap:12px; align-items:center; backdrop-filter: blur(15px); box-shadow: 0 5px 20px rgba(0,0,0,0.5); }
    #modeDot{ width:12px; height:12px; border-radius:50%; background:#55efc4; box-shadow: 0 0 20px rgba(85,239,196,0.7); }
    #modeText{ color:#e8e8e8; font-weight:900; letter-spacing:0.8px; }
    #exitXrBtn{ display:none; padding:10px 14px; border-radius:12px; border:1px solid rgba(255,255,255,0.2); background:rgba(255,255,255,0.1); color:#fff; cursor:pointer; font-weight:900; transition: 0.2s; text-transform: uppercase; font-size: 11px; letter-spacing: 0.5px; }
    #exitXrBtn:hover { background:rgba(255,255,255,0.15); }

    .loader { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 5000; display: none; place-items: center; flex-direction: column; gap: 20px; color: #a29bfe; font-size: 15px; font-weight: 900; letter-spacing: 3px; }
    .spinner { width: 50px; height: 50px; border: 5px solid #333; border-top-color: #6c5ce7; border-right-color: #a29bfe; border-radius: 50%; animation: spin 1s infinite linear; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .hint { font-size: 11px; color: #9aa5b1; line-height: 1.4; background: rgba(108, 92, 231, 0.08); border: 1px solid rgba(108, 92, 231, 0.2); padding: 12px; border-radius: 12px; margin-top: 12px; }
    .kbd { font-family: 'Consolas', monospace; font-size: 11px; color:#fff; background: rgba(108, 92, 231, 0.25); padding: 3px 8px; border-radius: 8px; border: 1px solid rgba(108, 92, 231, 0.3); font-weight: 700; }

    #mediaPlayer { position: fixed; bottom: 110px; left: 50%; transform: translateX(-50%); background: rgba(10, 10, 14, 0.97); backdrop-filter: blur(25px); border: 1px solid rgba(108, 92, 231, 0.3); border-radius: 18px; padding: 18px 24px; display: none; z-index: 150; box-shadow: 0 12px 45px rgba(0,0,0,0.8); min-width: 450px; }
    #mediaPlayer.show { display: block; }
    .media-type-badge { font-size: 10px; padding: 4px 10px; border-radius: 6px; background: rgba(108, 92, 231, 0.2); color: #a29bfe; font-weight: 800; letter-spacing: 0.5px; margin-bottom: 10px; display: inline-block; }
    .media-btn-row { display: flex; gap: 12px; align-items: center; margin-bottom: 14px; }
    .media-btn { width: 44px; height: 44px; border-radius: 50%; background: #2a2d35; border: 1px solid #555; display: grid; place-items: center; cursor: pointer; transition: 0.2s; font-size: 20px; }
    .media-btn:hover { background: #3a3d45; border-color: #6c5ce7; transform: scale(1.05); }
    .media-progress { flex: 1; height: 8px; background: #2a2d35; border-radius: 4px; cursor: pointer; position: relative; }
    .media-progress-bar { height: 100%; background: linear-gradient(90deg, #6c5ce7, #a29bfe); border-radius: 4px; width: 0%; transition: width 0.1s; }
    .media-time { font-size: 12px; color: #b2b9c6; font-family: 'Consolas', monospace; min-width: 110px; text-align: center; font-weight: 600; }

    .preset-grid { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0; }
    .preset-item { width: 38px; height: 38px; border-radius: 10px; cursor: pointer; border: 2px solid transparent; transition: 0.2s; position: relative; display: grid; place-items: center; font-size: 20px; }
    .preset-item:hover { border-color: #6c5ce7; transform: scale(1.1); }
    .preset-item.active { border-color: #a29bfe; box-shadow: 0 0 20px rgba(108,92,231,0.7); }

    .model-components { max-height: 180px; overflow-y: auto; background: rgba(0,0,0,0.4); border-radius: 10px; padding: 10px; margin: 10px 0; border: 1px solid rgba(255,255,255,0.05); }
    .model-comp-item { display: flex; align-items: center; gap: 10px; padding: 8px; font-size: 11px; border-radius: 8px; margin-bottom: 5px; background: rgba(255,255,255,0.02); transition: 0.2s; }
    .model-comp-item:hover { background: rgba(108, 92, 231, 0.1); }
    .model-comp-item input[type=checkbox] { width: 18px; height: 18px; cursor: pointer; }
    .model-comp-item label { font-size: 11px; flex: 1; cursor: pointer; color: #d1d5db; }

    #projectManager { background: rgba(108, 92, 231, 0.1); border: 1px solid rgba(108, 92, 231, 0.3); padding: 15px; border-radius: 12px; margin: 15px 0; }
    #projectManager input { width: 100%; padding: 10px; background: #1e1e24; border: 1px solid #444; border-radius: 8px; color: #eee; margin-bottom: 10px; font-size: 11px; }

    .view-mode-toggle { display: flex; gap: 8px; background: rgba(0,0,0,0.3); padding: 6px; border-radius: 10px; margin: 10px 0; }
    .view-mode-btn { flex: 1; padding: 10px; background: transparent; border: 1px solid transparent; border-radius: 8px; font-size: 11px; font-weight: 700; color: #999; cursor: pointer; transition: 0.2s; text-align: center; }
    .view-mode-btn.active { background: linear-gradient(135deg, #6c5ce7, #a29bfe); color: white; border-color: rgba(255,255,255,0.2); }

    .action-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 25px; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="loader" id="loader"><div class="spinner"></div><span>PROCESANDO...</span></div>
<div id="modeBadge"><div id="modeDot"></div><div id="modeText">MODO EDITOR</div><button id="exitXrBtn">SALIR</button></div>

<div id="mediaPlayer">
  <span class="media-type-badge" id="mediaTypeBadge">VIDEO</span>
  <div class="media-btn-row">
    <div class="media-btn" id="mediaPlayPause" title="Play/Pause">‚ñ∂Ô∏è</div>
    <div class="media-btn" id="mediaStop" title="Stop">‚èπÔ∏è</div>
    <div class="media-progress" id="mediaProgress">
      <div class="media-progress-bar" id="mediaProgressBar"></div>
    </div>
    <div class="media-time" id="mediaTime">0:00 / 0:00</div>
  </div>
  <div class="row">
    <label>üîä Volumen</label>
    <input type="range" id="mediaVolume" min="0" max="1" step="0.01" value="1" style="flex:2;">
    <span class="val" id="v_mediaVolume">100</span>
  </div>
</div>

<div class="ui-panel" id="ui">
  <h2>ü•Ω MR Studio Diamond <span class="ver-badge">v6.9 FIXED</span></h2>

  <div class="sec-head">üìÇ ARCHIVOS</div>
  <input type="file" id="fileInput" accept="image/*,video/*,.gif,.glb,.gltf,.fbx,.obj,audio/*" multiple style="display:none;" />
  <button class="warn" onclick="fileInput.click()">+ IMPORTAR ARCHIVOS</button>

  <div class="layer-list" id="layerList"></div>

  <div class="sec-head">üß≠ EDICI√ìN (Blender-Style)</div>
  <div class="row">
    <label><input type="checkbox" id="checkGrid" checked> Grilla</label>
    <label><input type="checkbox" id="checkAxes" checked> Ejes</label>
  </div>
  <div class="row">
    <label><input type="checkbox" id="checkSnap"> Snap (0.25m)</label>
    <label><input type="checkbox" id="checkGizmo" checked> Gizmos</label>
  </div>

  <div id="generalControls">
    <div class="sec-head">üìç PROYECCI√ìN</div>
    <div class="row">
      <select id="projSelect">
        <option value="plane">Plano 2D</option>
        <option value="360">Esfera 360¬∞ (Inmersiva)</option>
        <option value="180">Domo 180¬∞ (Inmersiva)</option>
      </select>
    </div>

    <div class="row" id="surfaceRow" style="display:none;">
      <label>üåç Superficie 360/180</label>
      <select id="surfaceSelect" style="flex:2;">
        <option value="sphere">Esfera</option>
        <option value="cube">Cubo</option>
        <option value="ellipsoid">Elipsoide (Tierra)</option>
      </select>
    </div>

    <div class="row" id="followRow" style="display:none;">
      <label title="Mantiene la superficie centrada en el observador">üìå Centrado en observador</label>
      <input type="checkbox" id="followViewer" style="flex:0; width:18px; height:18px;">
    </div>

    <div class="sec-head">üìè TRANSFORMACI√ìN</div>
    <div class="row">
      <label>X</label>
      <input type="range" id="posX" min="-10" max="10" step="0.01" value="0">
      <span class="val" id="v_posX">0.00</span>
    </div>
    <div class="row">
      <label>Y</label>
      <input type="range" id="posY" min="-10" max="10" step="0.01" value="0">
      <span class="val" id="v_posY">0.00</span>
    </div>
    <div class="row">
      <label>Z</label>
      <input type="range" id="posZ" min="-10" max="10" step="0.01" value="0">
      <span class="val" id="v_posZ">0.00</span>
    </div>

    <div class="sec-head">üîÑ ROTACI√ìN</div>
    <div class="row">
      <label>Rot Y</label>
      <input type="range" id="rotY" min="-180" max="180" step="1" value="0">
      <span class="val" id="v_rotY">0</span>
    </div>

    <div class="sec-head">üìê ESCALA</div>
    <div class="row">
      <label>Escala</label>
      <input type="range" id="scale" min="0.1" max="5" step="0.01" value="1">
      <span class="val" id="v_scale">1.00</span>
    </div>

    <div class="sec-head">üé® EFECTOS VISUALES</div>
    <div class="row">
      <label>Opacidad</label>
      <input type="range" id="opacity" min="0" max="1" step="0.01" value="1">
      <span class="val" id="v_opacity">1.00</span>
    </div>
    <div class="row">
      <label>Brillo</label>
      <input type="range" id="brightness" min="0" max="2" step="0.01" value="1">
      <span class="val" id="v_brightness">1.00</span>
    </div>
    <div class="row">
      <label>Contraste</label>
      <input type="range" id="contrast" min="0" max="2" step="0.01" value="1">
      <span class="val" id="v_contrast">1.00</span>
    </div>
    <div class="row">
      <label>Saturaci√≥n</label>
      <input type="range" id="saturation" min="0" max="2" step="0.01" value="1">
      <span class="val" id="v_saturation">1.00</span>
    </div>

    <div class="sec-head">üîë CHROMA KEY</div>
    <div class="row">
      <label><input type="checkbox" id="chromaEnable"> Activar Chroma</label>
    </div>
    
    <div class="preset-grid">
      <div class="preset-item" style="background:#00ff00" data-color="0,255,0" title="Verde"></div>
      <div class="preset-item" style="background:#0000ff" data-color="0,0,255" title="Azul"></div>
      <div class="preset-item" style="background:#ff00ff" data-color="255,0,255" title="Magenta"></div>
      <div class="preset-item" style="background:#ffff00" data-color="255,255,0" title="Amarillo"></div>
      <div class="preset-item" style="background:#ff0000" data-color="255,0,0" title="Rojo"></div>
      <div class="preset-item" style="background:#00ffff" data-color="0,255,255" title="Cyan"></div>
    </div>

    <div class="row">
      <label>üé® Color</label>
      <input type="text" id="chromaColorRGB" placeholder="R,G,B (ej: 0,255,0)" style="flex:2;">
    </div>
    <div class="row">
      <label>Tolerancia</label>
      <input type="range" id="chromaTolerance" min="0" max="1" step="0.01" value="0.4">
      <span class="val" id="v_chromaTolerance">0.40</span>
    </div>
    <div class="row">
      <label>Suavizado</label>
      <input type="range" id="chromaSmooth" min="0" max="0.5" step="0.01" value="0.1">
      <span class="val" id="v_chromaSmooth">0.10</span>
    </div>

    <div class="sec-head">üé≠ MODO DE VISTA</div>
    <div class="view-mode-toggle">
      <div class="view-mode-btn active" data-mode="normal">Normal</div>
      <div class="view-mode-btn" data-mode="immersive">Inmersivo</div>
    </div>
    <div class="hint">
      <strong>Normal:</strong> Objeto fijo en el espacio.<br>
      <strong>Inmersivo:</strong> La c√°mara siempre est√° dentro del objeto (para videos 360¬∞).
    </div>
  </div>

  <div id="modelControls" style="display:none;">
    <div class="sec-head">üé® RENDERIZADO 3D</div>
    <div class="row">
      <select id="modelRenderMode">
        <option value="default">Normal</option>
        <option value="wireframe">Wireframe</option>
        <option value="xray">X-Ray</option>
      </select>
    </div>
    <div class="sec-head">üß© COMPONENTES</div>
    <div class="model-components" id="modelComponentsList"></div>
  </div>

  <div id="audioControls" style="display:none;">
    <div class="sec-head">üîä AUDIO ESPACIAL</div>
    <div class="row">
      <label>Volumen</label>
      <input type="range" id="audioVolume" min="0" max="1" step="0.01" value="1">
      <span class="val" id="v_audioVolume">1.00</span>
    </div>
    <div class="row">
      <label>Dist. Ref.</label>
      <input type="range" id="audioRefDist" min="0.1" max="20" step="0.1" value="1">
      <span class="val" id="v_audioRefDist">1.0</span>
    </div>
    <div class="row">
      <label>Dist. M√°x.</label>
      <input type="range" id="audioMaxDist" min="1" max="100" step="1" value="50">
      <span class="val" id="v_audioMaxDist">50</span>
    </div>
    <div class="row">
      <label><input type="checkbox" id="audioLoop"> Loop</label>
    </div>
  </div>

  <div class="action-grid">
    <button class="danger" id="btnDelete">üóëÔ∏è Eliminar</button>
    <button class="warn" id="btnClearAll">üßπ Limpiar Todo</button>
  </div>

  <div class="sec-head">üíæ PROYECTO</div>
  <div id="projectManager">
    <input type="text" id="projectName" placeholder="Nombre del proyecto" value="Mi Escena MR">
    <div style="display:flex; gap:8px;">
      <button class="info" id="btnSaveProject" style="flex:1;">üíæ Guardar</button>
      <button class="info" id="btnLoadProject" style="flex:1;">üìÇ Cargar</button>
    </div>
    <input type="file" id="projectFileInput" accept=".mrsd" style="display:none;">
  </div>

  <div class="hint">
    <strong>Controles VR:</strong> <span class="kbd">Trigger</span> Seleccionar | <span class="kbd">Grip + Stick</span> Mover | <span class="kbd">2 Grips</span> Escalar
  </div>
</div>

<div class="toggle-ui" id="toggleBtn">‚öôÔ∏è</div>
<button id="vrBtn">ENTRAR A MODO MR</button>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
camera.position.set(0, 1.6, 3);

const orbit = new OrbitControls(camera, canvas);
orbit.enableDamping = true;
orbit.dampingFactor = 0.08;

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, 7);
scene.add(dirLight);

const gridHelper = new THREE.GridHelper(20, 20, 0x555555, 0x333333);
scene.add(gridHelper);
const axesHelper = new THREE.AxesHelper(5);
scene.add(axesHelper);

let objects = [];
let activeId = null;
let xrSession = null;
let rightRay = null;
let rayCursor = null;
let hoverId = null;

const ctrl = {
  right: { gripped: false, lastTrig: false, lastBtn: false, currPos: new THREE.Vector3(), currQuat: new THREE.Quaternion(), lastQuat: new THREE.Quaternion() },
  left: { gripped: false },
  gesture: { startDist: 0, startScale: 1 }
};

const audioListener = new THREE.AudioListener();
camera.add(audioListener);

let gltfLoader = new GLTFLoader();
let fbxLoader = new FBXLoader();
let objLoader = new OBJLoader();

// ========== FIXED: Crear geometr√≠a Elipsoide (Tierra aplastada) ==========
function createEllipsoidGeometry(radius = 1, widthSegments = 64, heightSegments = 32, flattenFactor = 0.85) {
  const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
  const positions = geometry.attributes.position;
  
  // Aplastar los polos (Y-axis)
  for (let i = 0; i < positions.count; i++) {
    const y = positions.getY(i);
    positions.setY(i, y * flattenFactor);
  }
  
  geometry.attributes.position.needsUpdate = true;
  geometry.computeVertexNormals();
  return geometry;
}

function defSettings() {
  return {
    projection: 'plane',
    surface: 'sphere',
    followViewer: false,
    viewMode: 'normal',
    posX: 0, posY: 0, posZ: 0,
    rotY: 0,
    scale: 1,
    opacity: 1,
    brightness: 1,
    contrast: 1,
    saturation: 1,
    chromaEnable: false,
    chromaColorRGB: '0,255,0',
    chromaTolerance: 0.4,
    chromaSmooth: 0.1
  };
}

// ========== FIXED: Geometr√≠a con soporte para Elipsoide ==========
function createGeometryForSurface(surface, projection) {
  const r = 10;
  switch(surface) {
    case 'cube':
      return new THREE.BoxGeometry(r * 2, r * 2, r * 2);
    case 'ellipsoid':
      return createEllipsoidGeometry(r, 64, 32, 0.85); // 15% aplastado
    case 'sphere':
    default:
      if (projection === '180') {
        return new THREE.SphereGeometry(r, 64, 32, 0, Math.PI * 2, 0, Math.PI / 2);
      }
      return new THREE.SphereGeometry(r, 64, 32);
  }
}

function chromaShader() {
  return {
    uniforms: {
      tDiffuse: { value: null },
      chromaKey: { value: new THREE.Vector3(0, 1, 0) },
      tolerance: { value: 0.4 },
      smoothness: { value: 0.1 },
      opacity: { value: 1 },
      brightness: { value: 1 },
      contrast: { value: 1 },
      saturation: { value: 1 },
      chromaEnable: { value: 0 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D tDiffuse;
      uniform vec3 chromaKey;
      uniform float tolerance;
      uniform float smoothness;
      uniform float opacity;
      uniform float brightness;
      uniform float contrast;
      uniform float saturation;
      uniform int chromaEnable;
      varying vec2 vUv;

      void main() {
        vec4 col = texture2D(tDiffuse, vUv);
        
        // Brillo/Contraste/Saturaci√≥n
        col.rgb *= brightness;
        col.rgb = (col.rgb - 0.5) * contrast + 0.5;
        float gray = dot(col.rgb, vec3(0.299, 0.587, 0.114));
        col.rgb = mix(vec3(gray), col.rgb, saturation);

        float alpha = opacity;
        
        if(chromaEnable == 1) {
          float d = distance(col.rgb, chromaKey);
          alpha *= smoothstep(tolerance - smoothness, tolerance + smoothness, d);
        }
        
        gl_FragColor = vec4(col.rgb, alpha * col.a);
      }
    `
  };
}

function buildShaderMaterial(obj) {
  const s = obj.settings;
  const shader = chromaShader();
  shader.uniforms.tDiffuse.value = obj.texture || new THREE.Texture();
  shader.uniforms.chromaEnable.value = s.chromaEnable ? 1 : 0;
  const rgb = s.chromaColorRGB.split(',').map(x => parseFloat(x.trim()) / 255);
  shader.uniforms.chromaKey.value.set(rgb[0] || 0, rgb[1] || 1, rgb[2] || 0);
  shader.uniforms.tolerance.value = s.chromaTolerance;
  shader.uniforms.smoothness.value = s.chromaSmooth;
  shader.uniforms.opacity.value = s.opacity;
  shader.uniforms.brightness.value = s.brightness;
  shader.uniforms.contrast.value = s.contrast;
  shader.uniforms.saturation.value = s.saturation;
  return new THREE.ShaderMaterial({
    uniforms: shader.uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader,
    transparent: true,
    side: THREE.DoubleSide
  });
}

// ========== FIXED: Recrear geometr√≠a al cambiar superficie ==========
function rebuildGeometry(obj) {
  const s = obj.settings;
  if (s.projection === 'plane') return;
  
  const oldGeom = obj.mesh.geometry;
  const newGeom = createGeometryForSurface(s.surface, s.projection);
  obj.mesh.geometry = newGeom;
  oldGeom.dispose();
  
  console.log(`‚úÖ Geometr√≠a actualizada a: ${s.surface}`);
}

function updateObj(prop, val) {
  const obj = objects.find(o => o.id === activeId);
  if (!obj) return;
  const s = obj.settings;
  
  if (prop === 'projection') {
    s.projection = val;
    const oldGeom = obj.mesh.geometry;
    
    if (val === 'plane') {
      obj.mesh.geometry = new THREE.PlaneGeometry(2, 2);
    } else {
      obj.mesh.geometry = createGeometryForSurface(s.surface, val);
    }
    oldGeom.dispose();
    obj.mesh.material = buildShaderMaterial(obj);
  } else if (prop === 'surface') {
    s.surface = val;
    rebuildGeometry(obj);
  } else if (prop === 'followViewer') {
    s.followViewer = val;
  } else if (prop === 'viewMode') {
    s.viewMode = val;
  } else if (prop === 'posX') {
    s.posX = val; obj.mesh.position.x = val;
  } else if (prop === 'posY') {
    s.posY = val; obj.mesh.position.y = val;
  } else if (prop === 'posZ') {
    s.posZ = val; obj.mesh.position.z = val;
  } else if (prop === 'rotY') {
    s.rotY = val; obj.mesh.rotation.y = THREE.MathUtils.degToRad(val);
  } else if (prop === 'scale') {
    s.scale = val; obj.mesh.scale.set(val, val, val);
  } else if (['opacity', 'brightness', 'contrast', 'saturation'].includes(prop)) {
    s[prop] = val;
    if (obj.mesh.material.uniforms) obj.mesh.material.uniforms[prop].value = val;
  } else if (prop === 'chromaEnable') {
    s.chromaEnable = val;
    if (obj.mesh.material.uniforms) obj.mesh.material.uniforms.chromaEnable.value = val ? 1 : 0;
  } else if (prop === 'chromaColorRGB') {
    s.chromaColorRGB = val;
    const rgb = val.split(',').map(x => parseFloat(x.trim()) / 255);
    if (obj.mesh.material.uniforms) obj.mesh.material.uniforms.chromaKey.value.set(rgb[0] || 0, rgb[1] || 1, rgb[2] || 0);
  } else if (prop === 'chromaTolerance') {
    s.chromaTolerance = val;
    if (obj.mesh.material.uniforms) obj.mesh.material.uniforms.tolerance.value = val;
  } else if (prop === 'chromaSmooth') {
    s.chromaSmooth = val;
    if (obj.mesh.material.uniforms) obj.mesh.material.uniforms.smoothness.value = val;
  }
  
  syncUI();
}

function syncUI() {
  const obj = objects.find(o => o.id === activeId);
  if (!obj) return;
  const s = obj.settings;

  document.getElementById('projSelect').value = s.projection;
  document.getElementById('surfaceSelect').value = s.surface;
  document.getElementById('followViewer').checked = s.followViewer;

  const isImmersive = (s.projection === '360' || s.projection === '180');
  document.getElementById('surfaceRow').style.display = isImmersive ? 'flex' : 'none';
  document.getElementById('followRow').style.display = isImmersive ? 'flex' : 'none';

  document.querySelectorAll('.view-mode-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === s.viewMode);
  });

  ['posX', 'posY', 'posZ', 'rotY', 'scale', 'opacity', 'brightness', 'contrast', 'saturation', 'chromaTolerance', 'chromaSmooth'].forEach(k => {
    const el = document.getElementById(k);
    const vel = document.getElementById('v_' + k);
    if (el && vel) {
      el.value = s[k];
      vel.textContent = typeof s[k] === 'number' ? s[k].toFixed(2) : s[k];
    }
  });

  document.getElementById('chromaEnable').checked = s.chromaEnable;
  document.getElementById('chromaColorRGB').value = s.chromaColorRGB;

  document.getElementById('generalControls').style.display = (obj.type === 'image' || obj.type === 'video' || obj.type === 'gif') ? 'block' : 'none';
  document.getElementById('modelControls').style.display = (obj.type === 'model') ? 'block' : 'none';
  document.getElementById('audioControls').style.display = (obj.type === 'audio') ? 'block' : 'none';
}

function selectObj(id) {
  activeId = id;
  updateList();
  syncUI();
  updateMediaPlayer();
}

function updateList() {
  const list = document.getElementById('layerList');
  list.innerHTML = '';
  objects.forEach((obj, idx) => {
    const div = document.createElement('div');
    div.className = 'layer-item';
    if (obj.id === activeId) div.classList.add('active');
    div.draggable = true;
    div.dataset.id = obj.id;
    
    const icon = obj.type === 'video' ? 'üé¨' : obj.type === 'image' ? 'üñºÔ∏è' : obj.type === 'gif' ? 'üéûÔ∏è' : obj.type === 'model' ? 'üßä' : 'üîä';
    div.innerHTML = `<span>${icon}</span><span style="flex:1;">${obj.name}</span>`;
    
    div.onclick = () => selectObj(obj.id);
    
    div.addEventListener('dragstart', e => {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', idx);
      div.classList.add('dragging');
    });
    
    div.addEventListener('dragend', () => div.classList.remove('dragging'));
    
    div.addEventListener('dragover', e => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    });
    
    div.addEventListener('drop', e => {
      e.preventDefault();
      const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
      const toIdx = idx;
      if (fromIdx !== toIdx) {
        const [moved] = objects.splice(fromIdx, 1);
        objects.splice(toIdx, 0, moved);
        updateList();
      }
    });
    
    list.appendChild(div);
  });
}

// ========== MEDIA PLAYER ==========
function updateMediaPlayer() {
  const obj = objects.find(o => o.id === activeId);
  const player = document.getElementById('mediaPlayer');
  
  if (!obj || (obj.type !== 'video' && obj.type !== 'audio')) {
    player.classList.remove('show');
    return;
  }
  
  player.classList.add('show');
  const badge = document.getElementById('mediaTypeBadge');
  badge.textContent = obj.type.toUpperCase();
  
  const media = obj.type === 'video' ? obj.video : obj.audio;
  
  // Play/Pause
  document.getElementById('mediaPlayPause').onclick = () => {
    if (media.paused) {
      media.play();
      document.getElementById('mediaPlayPause').textContent = '‚è∏Ô∏è';
    } else {
      media.pause();
      document.getElementById('mediaPlayPause').textContent = '‚ñ∂Ô∏è';
    }
  };
  
  // Stop
  document.getElementById('mediaStop').onclick = () => {
    media.pause();
    media.currentTime = 0;
    document.getElementById('mediaPlayPause').textContent = '‚ñ∂Ô∏è';
  };
  
  // Progress
  const progress = document.getElementById('mediaProgress');
  const progressBar = document.getElementById('mediaProgressBar');
  const timeDisplay = document.getElementById('mediaTime');
  
  progress.onclick = (e) => {
    const rect = progress.getBoundingClientRect();
    const percent = (e.clientX - rect.left) / rect.width;
    media.currentTime = percent * media.duration;
  };
  
  const updateProgress = () => {
    if (media.duration) {
      const percent = (media.currentTime / media.duration) * 100;
      progressBar.style.width = percent + '%';
      
      const formatTime = (sec) => {
        const m = Math.floor(sec / 60);
        const s = Math.floor(sec % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
      };
      
      timeDisplay.textContent = `${formatTime(media.currentTime)} / ${formatTime(media.duration)}`;
    }
  };
  
  media.addEventListener('timeupdate', updateProgress);
  
  // Volume
  const volumeSlider = document.getElementById('mediaVolume');
  const volumeVal = document.getElementById('v_mediaVolume');
  
  volumeSlider.value = media.volume;
  volumeVal.textContent = Math.round(media.volume * 100);
  
  volumeSlider.oninput = () => {
    media.volume = parseFloat(volumeSlider.value);
    volumeVal.textContent = Math.round(media.volume * 100);
  };
}

// ========== LOAD MEDIA ==========
async function loadVideo(dataURL, name, source, settings, transform) {
  const video = document.createElement('video');
  video.src = dataURL;
  video.crossOrigin = 'anonymous';
  video.loop = true;
  video.muted = false;
  video.playsInline = true;
  
  // CRITICAL FIX: Esperar a que el video cargue metadata
  await new Promise((resolve) => {
    video.addEventListener('loadedmetadata', resolve, { once: true });
  });
  
  const texture = new THREE.VideoTexture(video);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  
  const s = settings || defSettings();
  const geom = s.projection === 'plane' ? new THREE.PlaneGeometry(2, 2) : createGeometryForSurface(s.surface, s.projection);
  const mat = buildShaderMaterial({ settings: s, texture });
  
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.set(s.posX, s.posY, s.posZ);
  mesh.rotation.y = THREE.MathUtils.degToRad(s.rotY);
  mesh.scale.set(s.scale, s.scale, s.scale);
  
  scene.add(mesh);
  
  const obj = {
    id: Date.now() + Math.random(),
    name,
    type: 'video',
    mesh,
    video,
    texture,
    settings: s,
    source: source || { kind: 'dataurl', dataURL }
  };
  
  objects.push(obj);
  selectObj(obj.id);
  updateList();
  
  console.log('‚úÖ Video cargado:', name);
}

async function loadImg(dataURL, name, source, settings, transform) {
  const texture = await new THREE.TextureLoader().loadAsync(dataURL);
  texture.colorSpace = THREE.SRGBColorSpace;
  
  const s = settings || defSettings();
  const geom = s.projection === 'plane' ? new THREE.PlaneGeometry(2, 2) : createGeometryForSurface(s.surface, s.projection);
  const mat = buildShaderMaterial({ settings: s, texture });
  
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.set(s.posX, s.posY, s.posZ);
  mesh.rotation.y = THREE.MathUtils.degToRad(s.rotY);
  mesh.scale.set(s.scale, s.scale, s.scale);
  
  scene.add(mesh);
  
  const obj = {
    id: Date.now() + Math.random(),
    name,
    type: 'image',
    mesh,
    texture,
    settings: s,
    source: source || { kind: 'dataurl', dataURL }
  };
  
  objects.push(obj);
  selectObj(obj.id);
  updateList();
}

// ========== GIF SUPPORT ==========
let gifFrames = {};

function tickGifs(dt) {
  for (const obj of objects) {
    if (obj.type !== 'gif') continue;
    const gf = gifFrames[obj.id];
    if (!gf) continue;
    
    gf.elapsed += dt;
    if (gf.elapsed >= gf.frames[gf.frameIdx].delay / 1000) {
      gf.elapsed = 0;
      gf.frameIdx = (gf.frameIdx + 1) % gf.frames.length;
      const frame = gf.frames[gf.frameIdx];
      const imgData = new ImageData(new Uint8ClampedArray(frame.data), gf.width, gf.height);
      const canvas = document.createElement('canvas');
      canvas.width = gf.width;
      canvas.height = gf.height;
      canvas.getContext('2d').putImageData(imgData, 0, 0);
      obj.texture.image = canvas;
      obj.texture.needsUpdate = true;
    }
  }
}

async function loadGifFromArrayBuffer(ab, name, source, settings, transform) {
  const arr = new Uint8Array(ab);
  const reader = new GifReader(arr);
  const info = reader.frameInfo(0);
  const width = reader.width;
  const height = reader.height;
  const numFrames = reader.numFrames();
  
  const frames = [];
  for (let i = 0; i < numFrames; i++) {
    const fi = reader.frameInfo(i);
    const data = new Uint8Array(width * height * 4);
    reader.decodeAndBlitFrameRGBA(i, data);
    frames.push({ data, delay: fi.delay || 100 });
  }
  
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  const imgData = new ImageData(new Uint8ClampedArray(frames[0].data), width, height);
  ctx.putImageData(imgData, 0, 0);
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.colorSpace = THREE.SRGBColorSpace;
  
  const s = settings || defSettings();
  const geom = s.projection === 'plane' ? new THREE.PlaneGeometry(2, 2) : createGeometryForSurface(s.surface, s.projection);
  const mat = buildShaderMaterial({ settings: s, texture });
  
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.set(s.posX, s.posY, s.posZ);
  mesh.rotation.y = THREE.MathUtils.degToRad(s.rotY);
  mesh.scale.set(s.scale, s.scale, s.scale);
  
  scene.add(mesh);
  
  const id = Date.now() + Math.random();
  const obj = { id, name, type: 'gif', mesh, texture, settings: s, source: source || { kind: 'arrayBuffer', dataB64: btoa(String.fromCharCode(...arr)) } };
  objects.push(obj);
  
  gifFrames[id] = { frames, frameIdx: 0, elapsed: 0, width, height };
  
  selectObj(id);
  updateList();
}

// ========== AUDIO ==========
async function loadAudioFromDataURL(dataURL, name, source, settings, transform) {
  const audio = new THREE.PositionalAudio(audioListener);
  const loader = new THREE.AudioLoader();
  
  const buffer = await new Promise((resolve, reject) => {
    loader.load(dataURL, resolve, undefined, reject);
  });
  
  audio.setBuffer(buffer);
  audio.setRefDistance(1);
  audio.setMaxDistance(50);
  audio.setLoop(false);
  
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(0.1, 16, 16),
    new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 })
  );
  mesh.add(audio);
  
  const s = settings || defSettings();
  mesh.position.set(s.posX, s.posY, s.posZ);
  
  scene.add(mesh);
  
  const obj = {
    id: Date.now() + Math.random(),
    name,
    type: 'audio',
    mesh,
    audio,
    settings: s,
    source: source || { kind: 'dataurl', dataURL }
  };
  
  objects.push(obj);
  selectObj(obj.id);
  updateList();
}

// ========== 3D MODELS ==========
async function load3D(url, name, format, source, settings, transform) {
  let loaded;
  
  if (format === 'fbx') {
    loaded = await fbxLoader.loadAsync(url);
  } else if (format === 'obj') {
    loaded = await objLoader.loadAsync(url);
  } else {
    const gltf = await gltfLoader.loadAsync(url);
    loaded = gltf.scene;
  }
  
  const box = new THREE.Box3().setFromObject(loaded);
  const size = box.getSize(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const scale = 2 / maxDim;
  loaded.scale.multiplyScalar(scale);
  
  const s = settings || defSettings();
  loaded.position.set(s.posX, s.posY, s.posZ);
  loaded.rotation.y = THREE.MathUtils.degToRad(s.rotY);
  
  scene.add(loaded);
  
  const obj = {
    id: Date.now() + Math.random(),
    name,
    type: 'model',
    mesh: loaded,
    settings: s,
    source: source || null,
    renderMode: 'default',
    baseScale: scale
  };
  
  objects.push(obj);
  selectObj(obj.id);
  updateList();
  buildModelComponentsList(obj);
}

function buildModelComponentsList(obj) {
  const list = document.getElementById('modelComponentsList');
  list.innerHTML = '';
  
  const parts = [];
  obj.mesh.traverse(child => {
    if (child.isMesh && child.name) {
      parts.push(child);
    }
  });
  
  parts.forEach(part => {
    const div = document.createElement('div');
    div.className = 'model-comp-item';
    
    const chk = document.createElement('input');
    chk.type = 'checkbox';
    chk.checked = part.visible;
    chk.onchange = () => { part.visible = chk.checked; };
    
    const lbl = document.createElement('label');
    lbl.textContent = part.name || 'Sin nombre';
    lbl.onclick = () => { chk.checked = !chk.checked; part.visible = chk.checked; };
    
    div.appendChild(chk);
    div.appendChild(lbl);
    list.appendChild(div);
  });
}

function applyRenderMode(obj, mode) {
  obj.mesh.traverse(child => {
    if (child.isMesh) {
      if (mode === 'wireframe') {
        child.material.wireframe = true;
      } else if (mode === 'xray') {
        child.material.transparent = true;
        child.material.opacity = 0.3;
        child.material.wireframe = false;
      } else {
        child.material.wireframe = false;
        child.material.transparent = false;
        child.material.opacity = 1;
      }
    }
  });
}

// ========== FILE INPUT ==========
document.getElementById('fileInput').addEventListener('change', async e => {
  toggleLoader(true);
  for (const file of e.target.files) {
    const name = file.name;
    const ext = name.split('.').pop().toLowerCase();
    
    if (['jpg', 'jpeg', 'png', 'webp'].includes(ext)) {
      const dataURL = await fileToDataURL(file);
      await loadImg(dataURL, name);
    } else if (['mp4', 'webm', 'mov'].includes(ext)) {
      const dataURL = await fileToDataURL(file);
      await loadVideo(dataURL, name);
    } else if (ext === 'gif') {
      const ab = await file.arrayBuffer();
      await loadGifFromArrayBuffer(ab, name);
    } else if (['mp3', 'wav', 'ogg'].includes(ext)) {
      const dataURL = await fileToDataURL(file);
      await loadAudioFromDataURL(dataURL, name);
    } else if (['glb', 'gltf', 'fbx', 'obj'].includes(ext)) {
      const url = URL.createObjectURL(file);
      const format = ext === 'fbx' ? 'fbx' : ext === 'obj' ? 'obj' : 'gltf';
      await load3D(url, name, format);
    }
  }
  toggleLoader(false);
  e.target.value = '';
});

function fileToDataURL(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

function b64ToAb(b64) {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return arr.buffer;
}

// ========== UI CONTROLS ==========
['posX', 'posY', 'posZ', 'rotY', 'scale', 'opacity', 'brightness', 'contrast', 'saturation', 'chromaTolerance', 'chromaSmooth'].forEach(k => {
  const el = document.getElementById(k);
  const vel = document.getElementById('v_' + k);
  if (el && vel) {
    el.oninput = () => {
      vel.textContent = parseFloat(el.value).toFixed(2);
      updateObj(k, parseFloat(el.value));
    };
  }
});

document.getElementById('projSelect').onchange = (e) => updateObj('projection', e.target.value);
document.getElementById('surfaceSelect').onchange = (e) => updateObj('surface', e.target.value);
document.getElementById('followViewer').onchange = (e) => updateObj('followViewer', e.target.checked);
document.getElementById('chromaEnable').onchange = (e) => updateObj('chromaEnable', e.target.checked);
document.getElementById('chromaColorRGB').oninput = (e) => updateObj('chromaColorRGB', e.target.value);

document.querySelectorAll('.view-mode-btn').forEach(btn => {
  btn.onclick = () => updateObj('viewMode', btn.dataset.mode);
});

document.querySelectorAll('.preset-item').forEach(item => {
  item.onclick = () => {
    document.querySelectorAll('.preset-item').forEach(i => i.classList.remove('active'));
    item.classList.add('active');
    const rgb = item.dataset.color;
    document.getElementById('chromaColorRGB').value = rgb;
    updateObj('chromaColorRGB', rgb);
  };
});

document.getElementById('modelRenderMode').onchange = (e) => {
  const obj = objects.find(o => o.id === activeId);
  if (obj && obj.type === 'model') {
    obj.renderMode = e.target.value;
    applyRenderMode(obj, e.target.value);
  }
};

document.getElementById('audioVolume').oninput = (e) => {
  const obj = objects.find(o => o.id === activeId);
  if (obj && obj.type === 'audio') {
    obj.audio.setVolume(parseFloat(e.target.value));
    document.getElementById('v_audioVolume').textContent = parseFloat(e.target.value).toFixed(2);
  }
};

document.getElementById('audioRefDist').oninput = (e) => {
  const obj = objects.find(o => o.id === activeId);
  if (obj && obj.type === 'audio') {
    obj.audio.setRefDistance(parseFloat(e.target.value));
    document.getElementById('v_audioRefDist').textContent = parseFloat(e.target.value).toFixed(1);
  }
};

document.getElementById('audioMaxDist').oninput = (e) => {
  const obj = objects.find(o => o.id === activeId);
  if (obj && obj.type === 'audio') {
    obj.audio.setMaxDistance(parseFloat(e.target.value));
    document.getElementById('v_audioMaxDist').textContent = parseFloat(e.target.value);
  }
};

document.getElementById('audioLoop').onchange = (e) => {
  const obj = objects.find(o => o.id === activeId);
  if (obj && obj.type === 'audio') {
    obj.audio.setLoop(e.target.checked);
  }
};

document.getElementById('btnDelete').onclick = () => {
  const obj = objects.find(o => o.id === activeId);
  if (!obj) return;
  
  scene.remove(obj.mesh);
  if (obj.video) obj.video.pause();
  if (obj.audio) obj.audio.stop();
  if (obj.texture) obj.texture.dispose();
  if (obj.mesh.geometry) obj.mesh.geometry.dispose();
  if (obj.mesh.material) obj.mesh.material.dispose();
  
  objects = objects.filter(o => o.id !== activeId);
  activeId = null;
  updateList();
  syncUI();
  updateMediaPlayer();
};

document.getElementById('btnClearAll').onclick = () => {
  if (!confirm('¬øEliminar todos los objetos?')) return;
  window.clearScene();
};

window.clearScene = () => {
  objects.forEach(o => {
    scene.remove(o.mesh);
    if (o.video) o.video.pause();
    if (o.audio) o.audio.stop();
    if (o.texture) o.texture.dispose();
    if (o.mesh.geometry) o.mesh.geometry.dispose();
    if (o.mesh.material) o.mesh.material.dispose();
  });
  objects = [];
  activeId = null;
  gifFrames = {};
  updateList();
  syncUI();
  updateMediaPlayer();
};

document.getElementById('toggleBtn').onclick = () => {
  document.getElementById('ui').classList.toggle('hidden');
};

document.getElementById('checkGrid').onchange = (e) => {
  gridHelper.visible = e.target.checked;
};

document.getElementById('checkAxes').onchange = (e) => {
  axesHelper.visible = e.target.checked;
};

function toggleLoader(show) {
  document.getElementById('loader').style.display = show ? 'grid' : 'none';
}

// ========== XR ==========
async function init() {
  renderer.setAnimationLoop(render);
  initProjectIO();
  initRay();
  
  if (navigator.xr) {
    const supported = await navigator.xr.isSessionSupported('immersive-ar');
    if (supported) {
      document.getElementById('vrBtn').style.display = 'block';
      document.getElementById('vrBtn').onclick = startXR;
    }
  }
  
  document.getElementById('exitXrBtn').onclick = () => {
    if (xrSession) xrSession.end();
  };
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function setMode(isXR) {
  const badge = document.getElementById('modeBadge');
  const dot = document.getElementById('modeDot');
  const text = document.getElementById('modeText');
  const exitBtn = document.getElementById('exitXrBtn');
  const ui = document.getElementById('ui');
  
  if (isXR) {
    dot.style.background = '#fd79a8';
    dot.style.boxShadow = '0 0 20px rgba(253,121,168,0.7)';
    text.textContent = 'MODO MR ACTIVO';
    exitBtn.style.display = 'block';
    ui.classList.add('hidden');
    document.getElementById('vrBtn').style.display = 'none';
  } else {
    dot.style.background = '#55efc4';
    dot.style.boxShadow = '0 0 20px rgba(85,239,196,0.7)';
    text.textContent = 'MODO EDITOR';
    exitBtn.style.display = 'none';
    ui.classList.remove('hidden');
    document.getElementById('vrBtn').style.display = 'block';
  }
}

async function startXR() {
  const sessionInit = {
    requiredFeatures: ['local-floor'],
    optionalFeatures: ['dom-overlay', 'hand-tracking', 'hit-test'],
    domOverlay: { root: document.body }
  };
  
  try {
    xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);
    renderer.xr.setSession(xrSession);
    setMode(true);
    
    xrSession.addEventListener('end', () => {
      xrSession = null;
      setMode(false);
    });
  } catch (err) {
    console.error('Error XR:', err);
    alert('No se pudo iniciar MR.');
  }
}

function initRay() {
  rightRay = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(0, 0, -5)
    ]),
    new THREE.LineBasicMaterial({ color: 0x6c5ce7, linewidth: 3 })
  );
  scene.add(rightRay);
  
  rayCursor = new THREE.Mesh(
    new THREE.SphereGeometry(0.03),
    new THREE.MeshBasicMaterial({ color: 0xff7675 })
  );
  scene.add(rayCursor);
}

// ========== CRITICAL FIX: Manejo de VR sin crash ==========
function handleVR(frame, dt) {
  if (!xrSession) return;
  
  const ref = renderer.xr.getReferenceSpace();
  if (!ref) return;
  
  let lSrc, rSrc;
  for (const s of xrSession.inputSources) {
    if (s.handedness === 'left') lSrc = s;
    if (s.handedness === 'right') rSrc = s;
  }
  
  if (rSrc && rSrc.gripSpace) {
    const p = frame.getPose(rSrc.gripSpace, ref);
    if (p) {
      const pos = p.transform.position;
      rightRay.position.set(pos.x, pos.y, pos.z);
      rightRay.quaternion.set(
        p.transform.orientation.x,
        p.transform.orientation.y,
        p.transform.orientation.z,
        p.transform.orientation.w
      );
      rightRay.visible = true;
      
      const orig = new THREE.Vector3(pos.x, pos.y, pos.z);
      const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(rightRay.quaternion);
      const targets = objects
        .filter(o => o.settings.projection === 'plane' || o.type === 'model')
        .map(o => o.mesh);
      const hits = new THREE.Raycaster(orig, dir, 0, 10).intersectObjects(targets, true);
      
      if (hits.length > 0) {
        rayCursor.visible = true;
        rayCursor.position.copy(hits[0].point);
        let m = hits[0].object;
        const found = objects.find(o => {
          let x = m;
          while (x) {
            if (x === o.mesh) return true;
            x = x.parent;
          }
          return false;
        });
        hoverId = found ? found.id : null;
      } else {
        rayCursor.visible = false;
        hoverId = null;
      }
      
      ctrl.right.currPos = orig;
      ctrl.right.currQuat = rightRay.quaternion.clone();
    }
  }
  
  if (rSrc && rSrc.gamepad) {
    const gp = rSrc.gamepad;
    const trig = gp.buttons[0].pressed;
    const grip = gp.buttons[1].pressed;
    const btnA = gp.buttons[4]?.pressed || gp.buttons[5]?.pressed;
    
    if (trig && !ctrl.right.lastTrig && hoverId) {
      selectObj(hoverId);
    }
    ctrl.right.lastTrig = trig;
    
    if (btnA && !ctrl.right.lastBtn && activeId) {
      const o = objects.find(x => x.id === activeId);
      if (o && o.video) {
        if (o.video.paused) o.video.play();
        else o.video.pause();
      }
    }
    ctrl.right.lastBtn = btnA;
    
    const sx = gp.axes[2] || 0;
    const sy = gp.axes[3] || 0;
    
    if (grip) {
      const obj = objects.find(o => o.id === activeId);
      if (obj && (obj.settings.projection === 'plane' || obj.type === 'model')) {
        if (Math.abs(sx) > 0.1) obj.mesh.position.x += sx * dt * 2;
        if (Math.abs(sy) > 0.1) obj.mesh.position.z += sy * dt * 2;
        
        if (ctrl.right.gripped) {
          const dQ = ctrl.right.currQuat.clone().multiply(ctrl.right.lastQuat.clone().invert());
          obj.mesh.quaternion.premultiply(dQ);
          obj.settings.rotY = THREE.MathUtils.radToDeg(obj.mesh.rotation.y);
          syncUI();
        }
        
        if (lSrc && lSrc.gamepad) {
          const lGrip = lSrc.gamepad.buttons[1].pressed;
          const lsy = lSrc.gamepad.axes[3] || 0;
          if (Math.abs(lsy) > 0.1) {
            obj.mesh.position.y -= lsy * dt;
            obj.settings.posY = obj.mesh.position.y;
            syncUI();
          }
          
          if (lGrip && lSrc.gripSpace) {
            const lp = frame.getPose(lSrc.gripSpace, ref);
            if (lp) {
              const d = new THREE.Vector3(lp.transform.position.x, lp.transform.position.y, lp.transform.position.z).distanceTo(ctrl.right.currPos);
              if (!ctrl.left.gripped) {
                ctrl.gesture.startDist = d;
                ctrl.gesture.startScale = obj.settings.scale;
              } else {
                const ns = Math.max(0.01, ctrl.gesture.startScale * (d / ctrl.gesture.startDist));
                updateObj('scale', ns);
              }
            }
            ctrl.left.gripped = true;
          } else {
            ctrl.left.gripped = false;
          }
        }
      }
      ctrl.right.gripped = true;
      ctrl.right.lastQuat.copy(ctrl.right.currQuat);
    } else {
      ctrl.right.gripped = false;
    }
  }
}

let lastTime = performance.now();

// ========== CRITICAL FIX: Render loop optimizado ==========
function render(time, frame) {
  const dt = Math.min(0.05, (time - lastTime) / 1000);
  lastTime = time;
  
  if (!xrSession) orbit.update();
  
  tickGifs(dt);
  
  // Actualizar uniforms de tiempo
  objects.forEach(o => {
    if (o.mesh?.material?.uniforms?.time) {
      o.mesh.material.uniforms.time.value = time / 1000;
    }
  });
  
  // FIXED: Solo actualizar posici√≥n si est√° en modo inmersivo
  for (const obj of objects) {
    if (obj.type === 'model' || obj.type === 'audio') continue;
    
    const s = obj.settings;
    if ((s.projection !== '360' && s.projection !== '180')) continue;
    if (!s.followViewer) continue;
    if (s.viewMode !== 'immersive') continue;
    
    const cam = renderer.xr.isPresenting ? renderer.xr.getCamera(camera) : camera;
    obj.mesh.position.copy(cam.position);
  }
  
  if (frame) handleVR(frame, dt);
  
  renderer.render(scene, camera);
}

// ========== PROJECT I/O ==========
function initProjectIO() {
  document.getElementById('btnSaveProject').onclick = saveProject;
  document.getElementById('btnLoadProject').onclick = () => document.getElementById('projectFileInput').click();
  document.getElementById('projectFileInput').addEventListener('change', async e => {
    if (!e.target.files.length) return;
    const file = e.target.files[0];
    try {
      const text = await file.text();
      await loadProjectData(JSON.parse(text));
    } catch (err) {
      console.error(err);
      alert('Error cargando proyecto.');
    }
    e.target.value = '';
  });
}

async function saveProject() {
  const projectName = document.getElementById('projectName').value || 'Mi Escena MR';
  const serialized = [];
  
  for (const o of objects) {
    serialized.push({
      id: o.id,
      name: o.name,
      type: o.type,
      settings: o.settings,
      renderMode: o.renderMode || null,
      baseScale: o.baseScale || null,
      transform: {
        position: { x: o.mesh.position.x, y: o.mesh.position.y, z: o.mesh.position.z },
        rotation: { x: o.mesh.rotation.x, y: o.mesh.rotation.y, z: o.mesh.rotation.z },
        scale: { x: o.mesh.scale.x, y: o.mesh.scale.y, z: o.mesh.scale.z }
      },
      source: o.source || null
    });
  }
  
  const blob = new Blob([JSON.stringify({
    version: '6.9-fixed',
    name: projectName,
    created: new Date().toISOString(),
    objects: serialized
  }, null, 2)], { type: 'application/json' });
  
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `${projectName.replace(/\s+/g, '_')}.mrsd`;
  a.click();
}

async function loadProjectData(data) {
  console.log('üìÇ Cargando:', data.name);
  toggleLoader(true);
  window.clearScene();
  
  document.getElementById('projectName').value = data.name || 'Mi Escena MR';
  
  for (const rec of (data.objects || [])) {
    try {
      const s = rec.settings || defSettings();
      const t = rec.transform || null;
      const src = rec.source || null;
      if (!src) continue;
      
      const type = rec.type;
      
      if (type === 'video') {
        await loadVideo(src.kind === 'dataurl' ? src.dataURL : '', rec.name.toLowerCase(), src, s, t);
      } else if (type === 'image') {
        await loadImg(src.kind === 'dataurl' ? src.dataURL : '', rec.name.toLowerCase(), src, s, t);
      } else if (type === 'gif') {
        await loadGifFromArrayBuffer(b64ToAb(src.dataB64 || ''), rec.name.toLowerCase(), src, s, t);
      } else if (type === 'audio') {
        await loadAudioFromDataURL(src.kind === 'dataurl' ? src.dataURL : '', rec.name.toLowerCase(), src, s, t);
      } else if (type === 'model') {
        const url = URL.createObjectURL(new Blob([b64ToAb(src.dataB64 || '')], { type: src.mime || 'application/octet-stream' }));
        const ext = (src.ext || '').toLowerCase();
        await load3D(url, rec.name.toLowerCase(), (ext === 'fbx' ? 'fbx' : (ext === 'obj' ? 'obj' : 'gltf')), src, s, t);
        const created = objects[objects.length - 1];
        if (created && rec.renderMode) {
          created.renderMode = rec.renderMode;
          applyRenderMode(created, rec.renderMode);
        }
      }
    } catch (err) {
      console.error('Error objeto:', rec.name, err);
    }
  }
  
  updateList();
  toggleLoader(false);
  alert(`Proyecto "${data.name}" cargado.`);
}

init();
</script>
</body>
</html>
