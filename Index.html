<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>MR Studio Diamond v4.0 (Editor+MR Workflow)</title>
  <script src="https://unpkg.com/omggif@1.0.10/omggif.js"></script>
  <style>
    * { box-sizing: border-box; user-select: none; }
    body { margin: 0; overflow: hidden; background: transparent; font-family: 'Segoe UI', system-ui, sans-serif; color: #eee; }
    #c { position: fixed; inset: 0; width: 100%; height: 100%; touch-action: none; z-index: 0; }

    .ui-panel {
      position: fixed; left: 20px; top: 20px; width: 360px; max-height: 95vh;
      background: rgba(10, 10, 14, 0.95); backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 16px;
      padding: 18px; overflow-y: auto; z-index: 100;
      box-shadow: 0 20px 50px rgba(0,0,0,0.8);
      transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      scrollbar-width: thin; scrollbar-color: #444 transparent;
    }
    .ui-panel.hidden { transform: translateX(-420px); }

    h2 { margin: 0 0 15px 0; font-size: 18px; color: #a29bfe; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
    .sec-head { font-size: 11px; font-weight: 700; color: #aaa; margin: 15px 0 8px 0; text-transform: uppercase; letter-spacing: 0.5px; }

    .row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
    label { font-size: 12px; flex: 1; color: #ccc; white-space: nowrap; font-weight: 500; }
    input[type=range] { flex: 2; height: 4px; background: #333; border-radius: 2px; accent-color: #6c5ce7; cursor: pointer; }
    .val { width: 44px; text-align: right; font-size: 11px; font-family: monospace; color: #a29bfe; }
    select, input[type=file] { width: 100%; background: #1e1e24; border: 1px solid #444; color: #eee; padding: 8px; border-radius: 8px; font-size: 11px; outline: none; }

    button { flex: 1; padding: 12px; border-radius: 8px; border: none; font-size: 12px; font-weight: 700; cursor: pointer; color: white; background: #333; transition: 0.2s; }
    button.primary { background: linear-gradient(135deg, #6c5ce7, #a29bfe); box-shadow: 0 4px 15px rgba(108,92,231,0.3); }
    button.danger { background: rgba(255, 71, 87, 0.15); border: 1px solid rgba(255, 71, 87, 0.3); color: #ff7675; }
    button.warn { background: rgba(253, 203, 110, 0.15); border: 1px solid rgba(253, 203, 110, 0.3); color: #ffeaa7; }

    .layer-list { max-height: 140px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 5px; margin-bottom: 10px; }
    .layer-item { padding: 10px; font-size: 12px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 10px; margin-bottom: 4px; border: 1px solid transparent; }
    .layer-item.active { background: rgba(108, 92, 231, 0.25); border-color: rgba(108, 92, 231, 0.5); color: white; }

    .toggle-ui { position: fixed; bottom: 25px; right: 25px; width: 50px; height: 50px; background: #1e1e24; border-radius: 50%; display: grid; place-items: center; font-size: 20px; border: 1px solid #555; z-index: 200; cursor: pointer; box-shadow: 0 5px 20px rgba(0,0,0,0.5); }
    #vrBtn { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); padding: 14px 45px; background: linear-gradient(135deg, #6c5ce7, #0984e3); color: white; border-radius: 50px; border: none; font-weight: 800; cursor: pointer; z-index: 1000; display: none; box-shadow: 0 0 30px rgba(108,92,231,0.6); animation: pulse 2s infinite; }
    @keyframes pulse { 0% {box-shadow: 0 0 20px rgba(108,92,231,0.6);} 50% {box-shadow: 0 0 40px rgba(108,92,231,0.8);} 100% {box-shadow: 0 0 20px rgba(108,92,231,0.6);} }

    #modeBadge{
      position: fixed; top: 18px; right: 18px; z-index: 1200;
      background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.12);
      padding: 10px 12px; border-radius: 12px; font-size: 12px;
      display:flex; gap:10px; align-items:center;
      backdrop-filter: blur(10px);
    }
    #modeDot{ width:10px; height:10px; border-radius:50%; background:#55efc4; box-shadow: 0 0 18px rgba(85,239,196,0.6); }
    #modeText{ color:#ddd; font-weight:800; letter-spacing:0.6px; }
    #exitXrBtn{ display:none; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.16); background:rgba(255,255,255,0.08); color:#fff; cursor:pointer; font-weight:800; }

    .loader { position: fixed; inset: 0; background: rgba(0,0,0,0.92); z-index: 5000; display: none; place-items: center; flex-direction: column; gap: 15px; color: #a29bfe; font-size: 14px; font-weight: bold; letter-spacing: 2px; }
    .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top-color: #a29bfe; border-radius: 50%; animation: spin 1s infinite linear; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .disabled-overlay{
      opacity: 0.55;
      filter: saturate(0.9);
      pointer-events: none;
    }

    .hint {
      font-size: 11px; color: #9aa0a6; line-height: 1.3;
      background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08);
      padding: 10px; border-radius: 10px; margin-top: 10px;
    }
    .kbd { font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 11px; color:#fff;
      background: rgba(255,255,255,0.12); padding: 2px 6px; border-radius: 7px; border: 1px solid rgba(255,255,255,0.12);
    }
  </style>
</head>
<body>

<canvas id="c"></canvas>
<div class="loader" id="loader"><div class="spinner"></div><span>CARGANDO...</span></div>

<div id="modeBadge">
  <div id="modeDot"></div>
  <div id="modeText">MODO EDITOR</div>
  <button id="exitXrBtn" title="Salir de XR para editar propiedades">SALIR A EDICI√ìN</button>
</div>

<div class="ui-panel" id="ui">
  <h2>ü•Ω MR Studio Diamond v4.0</h2>

  <div class="sec-head">üìÇ Archivos <button class="warn" style="padding:4px; font-size:10px; width:auto; flex:0;" onclick="fileInput.click()">+ IMPORTAR</button></div>
  <input type="file" id="fileInput" accept="image/*,video/*,.gif,.glb,.gltf,.fbx,.obj" multiple style="display:none;" />

  <div class="layer-list" id="layerList"></div>

  <div class="sec-head">üß≠ Editor (tipo Blender)</div>
  <div class="row">
    <label><input type="checkbox" id="checkGrid" checked> Grilla</label>
    <label><input type="checkbox" id="checkAxes" checked> Ejes</label>
  </div>
  <div class="row">
    <label><input type="checkbox" id="checkSnap"> Snap (0.25m)</label>
    <label><input type="checkbox" id="checkGizmo" checked> Gizmos</label>
  </div>

  <div id="generalControls">
    <div class="sec-head">üìç Proyecci√≥n</div>
    <div class="row">
      <select id="projSelect">
        <option value="plane">Plano 2D</option>
        <option value="360">Esfera 360¬∞ (Inmersiva)</option>
        <option value="180">Domo 180¬∞ (Inmersiva)</option>
      </select>
    </div>

    <div class="row" id="surfaceRow" style="display:none;">
      <label>Superficie 360/180</label>
      <select id="surfaceSelect" style="flex:2;">
        <option value="sphere">Esfera</option>
        <option value="cube">Cubo</option>
        <option value="ovoid">Ovoide</option>
      </select>
    </div>

    <div class="row" id="followRow" style="display:none;">
      <label title="Mantiene la superficie centrada en el observador (√∫til para reencuadre)">Centrado en observador</label>
      <input type="checkbox" id="followViewer" style="flex:0; width:18px; height:18px;">
    </div>

    <div class="sec-head">üìè Transformaci√≥n</div>
    <div class="row">
      <label>Escala</label><input type="range" id="scale" min="0.1" max="10" step="0.05" value="1">
      <span class="val" id="v_scale">1.0</span>
    </div>
    <div class="row">
      <label>Modo Espejo (Flip H)</label>
      <input type="checkbox" id="checkFlip" style="flex:0; width:18px; height:18px;">
    </div>

    <div id="posControls">
      <div class="row"><label>Distancia</label><input type="range" id="dist" min="0" max="15" step="0.1" value="2"><span class="val" id="v_dist">2.0</span></div>
      <div class="row"><label>Altura</label><input type="range" id="height" min="-5" max="5" step="0.1" value="1.6"><span class="val" id="v_height">1.6</span></div>
    </div>
    <div class="row"><label>Rotaci√≥n Y</label><input type="range" id="rotY" min="0" max="360" step="1" value="0"><span class="val" id="v_rotY">0</span></div>
  </div>

  <!-- IMPORTANT: Estas propiedades quedan BLOQUEADAS en XR (modo MR) para que no sea accidente -->
  <div id="mediaControls" style="display:none;">
    <div class="sec-head">üé® Color & Imagen</div>
    <div class="row"><label>Brillo</label><input type="range" id="brightness" min="-1" max="1" step="0.05" value="0"><span class="val" id="v_brightness">0.0</span></div>
    <div class="row"><label>Contraste</label><input type="range" id="contrast" min="0" max="3" step="0.1" value="1"><span class="val" id="v_contrast">1.0</span></div>
    <div class="row"><label>Saturaci√≥n</label><input type="range" id="saturation" min="0" max="3" step="0.1" value="1"><span class="val" id="v_saturation">1.0</span></div>
    <div class="row"><label>Gamma</label><input type="range" id="gamma" min="0.1" max="3" step="0.1" value="1"><span class="val" id="v_gamma">1.0</span></div>

    <div class="sec-head">üßº Anti dominante (360 ‚Äúgris azulado‚Äù)</div>
    <div class="row"><label>Anti-azulado</label><input type="range" id="deblue" min="0" max="1" step="0.01" value="0"><span class="val" id="v_deblue">0.00</span></div>

    <div class="sec-head">üñºÔ∏è Ajuste Visual</div>
    <div class="row"><label>Desfase X</label><input type="range" id="offsetX" min="-1" max="1" step="0.01" value="0"><span class="val" id="v_offsetX">0.0</span></div>
    <div class="row"><label>Desfase Y</label><input type="range" id="offsetY" min="-1" max="1" step="0.01" value="0"><span class="val" id="v_offsetY">0.0</span></div>

    <div class="sec-head">üü© Chroma Key Pro (Face Protect)</div>
    <div class="row">
      <label>Activar</label> <input type="checkbox" id="chromaActive" style="flex:0; width:18px; height:18px;">
      <label style="margin-left:15px">Invertir</label> <input type="checkbox" id="chromaInvert" style="flex:0; width:18px; height:18px;">
    </div>

    <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:8px; margin:8px 0; border:1px solid rgba(255,255,255,0.05);">
      <div class="row"><label style="color:#ff7675">Rojo</label><input type="range" id="keyR" min="0" max="1" step="0.01" value="0"><span class="val" id="v_keyR">0.0</span></div>
      <div class="row"><label style="color:#55efc4">Verde</label><input type="range" id="keyG" min="0" max="1" step="0.01" value="1"><span class="val" id="v_keyG">1.0</span></div>
      <div class="row"><label style="color:#74b9ff">Azul</label><input type="range" id="keyB" min="0" max="1" step="0.01" value="0"><span class="val" id="v_keyB">0.0</span></div>
      <div id="colorPrev" style="height:8px; width:100%; border-radius:4px; background:#0f0; margin-top:6px; transition:0.3s;"></div>
    </div>

    <div class="row"><label>Similitud</label><input type="range" id="sim" min="0" max="1" step="0.001" value="0.4"><span class="val" id="v_sim">0.4</span></div>
    <div class="row"><label>Suavizado</label><input type="range" id="smooth" min="0" max="0.5" step="0.001" value="0.05"><span class="val" id="v_smooth">0.05</span></div>
    <div class="row"><label>Opacidad</label><input type="range" id="opacity" min="0" max="1" step="0.05" value="1"><span class="val" id="v_opacity">1.0</span></div>

    <div class="hint">
      En <b>MR</b> estas propiedades se bloquean por seguridad. Para editar color/chroma, usa <b>SALIR A EDICI√ìN</b>.
    </div>
  </div>

  <div class="btn-group" style="margin-top:20px;">
    <button class="primary" onclick="centerActive()">üéØ Centrar</button>
    <button class="warn" onclick="reloadVideo()">üîÑ Recargar Video</button>
    <button class="danger" onclick="deleteActive()">üóëÔ∏è Borrar</button>
  </div>

  <div class="row" style="margin-top:20px; font-size:11px; color:#888; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
    <label title="Requiere reiniciar sesi√≥n VR"><input type="checkbox" id="checkOcclusion" checked> Oclusi√≥n (Mundo Real)</label>
  </div>

  <div class="hint">
    Atajos: <span class="kbd">G</span> mover, <span class="kbd">R</span> rotar, <span class="kbd">S</span> escala,
    <span class="kbd">Supr</span> borrar, click para seleccionar.
  </div>
</div>

<div class="toggle-ui" onclick="toggleUI()">üëÅÔ∏è</div>
<button id="vrBtn">ENTRAR EN MR</button>

<script type="importmap">
  { "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    } }
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { TransformControls } from 'three/addons/controls/TransformControls.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let scene, camera, renderer, xrSession;
let objects = [];
let activeId = null;
let transformControl, orbit;
let grid, axes;
let raycaster, mouse = new THREE.Vector2();
let hoverId;

const ctrl = {
  right: { gripped: false, lastPos: new THREE.Vector3(), lastQuat: new THREE.Quaternion(), lastTrig: false, lastBtn: false },
  left: { gripped: false },
  gesture: { active: false, startDist: 0, startScale: 1 }
};
let rightRay, rayCursor;

const vert = `
varying vec2 vUv;
uniform vec2 offset;
void main() {
  vUv = uv + offset;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`;

const frag = `
uniform sampler2D map;
uniform bool chromaEnabled, chromaInvert;
uniform vec3 keyColor;
uniform float similarity, smoothness, opacity;
uniform float brightness, contrast, saturation, gamma;
uniform float deblue;

varying vec2 vUv;

vec3 rgb2hsv(vec3 c) {
  vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10;
  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 adjustColor(vec3 color) {
  color += brightness;
  color = (color - 0.5) * contrast + 0.5;
  float gray = dot(color, vec3(0.299, 0.587, 0.114));
  color = mix(vec3(gray), color, saturation);
  color = pow(max(color, 0.0), vec3(1.0 / gamma));
  return color;
}

// Neutraliza dominante azul/cian en zonas de baja saturaci√≥n (t√≠pico "gris azulado" 360)
vec3 removeBlueGray(vec3 col, float amt) {
  if(amt <= 0.0) return col;
  vec3 hsv = rgb2hsv(col);
  float lowSat = 1.0 - smoothstep(0.20, 0.45, hsv.y);      // m√°s efecto en saturaci√≥n baja
  float midVal = smoothstep(0.15, 0.95, hsv.z);            // evita negros puros
  float hueCyan = 1.0 - smoothstep(0.20, 0.32, abs(hsv.x - 0.50)); // ~ cian/azul (0.5 en hsv)
  float w = amt * lowSat * midVal * hueCyan;

  // reduce azul un poco y compensa hacia gris neutro
  float g = dot(col, vec3(0.299, 0.587, 0.114));
  vec3 neutral = vec3(g);
  vec3 outc = mix(col, neutral, w * 0.65);
  outc.b = mix(outc.b, outc.b * (1.0 - 0.35*w), 1.0); // baja azul
  return outc;
}

void main() {
  vec4 tex = texture2D(map, vUv);
  vec3 col = tex.rgb;
  float alpha = tex.a * opacity;

  if (chromaEnabled) {
    vec3 hsv = rgb2hsv(col);
    vec3 kHsv = rgb2hsv(keyColor);

    float hueDist = abs(hsv.x - kHsv.x);
    if (hueDist > 0.5) hueDist = 1.0 - hueDist;
    float dist = sqrt(pow(hueDist * 2.0, 2.0) + pow(hsv.y - kHsv.y, 2.0));
    float mask = smoothstep(similarity, similarity + smoothness, dist);

    // PROTECCI√ìN DE ROJOS (Ojos/Labios)
    float protection = 0.0;
    if(keyColor.g > keyColor.r && keyColor.g > keyColor.b) {
      protection = (col.r - col.g) * 3.0;
    } else if(keyColor.b > keyColor.r && keyColor.b > keyColor.g) {
      protection = (col.r - col.b) * 3.0;
    }
    if(protection > 0.0) mask = clamp(mask + protection, 0.0, 1.0);

    if (!chromaInvert) {
      alpha *= mask;
      if(mask < 0.9) {
        float maxRB = max(col.r, col.b);
        float maxRG = max(col.r, col.g);
        if (keyColor.g > keyColor.r && keyColor.g > keyColor.b && col.g > maxRB) col.g = mix(col.g, maxRB, 1.0-mask);
        else if (keyColor.b > keyColor.g && keyColor.b > keyColor.r && col.b > maxRG) col.b = mix(col.b, maxRG, 1.0-mask);
      }
    } else {
      alpha *= (1.0 - mask);
    }
  }

  col = removeBlueGray(col, deblue);
  col = adjustColor(col);

  gl_FragColor = vec4(col, alpha);
  if (alpha < 0.01) discard;
}
`;

function init() {
  renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), alpha: true, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.xr.setReferenceSpaceType('local-floor');

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 2000);
  camera.position.set(0, 1.6, 3);

  scene.add(new THREE.AmbientLight(0xffffff, 1.2));
  const d = new THREE.DirectionalLight(0xffffff, 1.5); d.position.set(2, 5, 2); scene.add(d);

  // Editor grid/axes
  grid = new THREE.GridHelper(30, 60, 0x444444, 0x222222);
  grid.position.y = 0;
  scene.add(grid);

  axes = new THREE.AxesHelper(1.2);
  axes.position.set(0, 0.01, 0);
  scene.add(axes);

  // Orbit (Editor)
  orbit = new OrbitControls(camera, renderer.domElement);
  orbit.enableDamping = true;
  orbit.dampingFactor = 0.06;
  orbit.target.set(0, 1.6, 0);
  orbit.update();

  transformControl = new TransformControls(camera, renderer.domElement);
  transformControl.addEventListener('dragging-changed', e=>{
    orbit.enabled = !e.value; // mientras arrastras gizmo, no orbit
  });
  transformControl.setTranslationSnap(null);
  transformControl.setRotationSnap(null);
  transformControl.setScaleSnap(null);
  scene.add(transformControl);

  setupVR();
  initRay();
  initMousePick();
  initShortcuts();

  document.getElementById('checkGrid').addEventListener('change', e=>grid.visible=e.target.checked);
  document.getElementById('checkAxes').addEventListener('change', e=>axes.visible=e.target.checked);
  document.getElementById('checkGizmo').addEventListener('change', e=>transformControl.visible=e.target.checked);
  document.getElementById('checkSnap').addEventListener('change', e=>{
    const on = e.target.checked;
    transformControl.setTranslationSnap(on ? 0.25 : null);
  });

  window.addEventListener('resize', onResize);
  renderer.setAnimationLoop(render);

  // badge
  document.getElementById('exitXrBtn').onclick = ()=>{ if(xrSession) xrSession.end(); };
  setMode(false);
}

function onResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function setMode(isXR){
  const dot = document.getElementById('modeDot');
  const text = document.getElementById('modeText');
  const exitBtn = document.getElementById('exitXrBtn');

  if(isXR){
    dot.style.background = '#ff7675';
    dot.style.boxShadow = '0 0 18px rgba(255,118,117,0.7)';
    text.innerText = 'MODO MR (PREVIEW)';
    exitBtn.style.display = 'inline-block';

    // Bloqueo de propiedades en XR (para que no sea accidente)
    document.getElementById('mediaControls').classList.add('disabled-overlay');

    // En MR no quieres orbit (c√°mara XR manda)
    orbit.enabled = false;
  } else {
    dot.style.background = '#55efc4';
    dot.style.boxShadow = '0 0 18px rgba(85,239,196,0.6)';
    text.innerText = 'MODO EDITOR';
    exitBtn.style.display = 'none';

    document.getElementById('mediaControls').classList.remove('disabled-overlay');
    orbit.enabled = true;
  }
}

// ======= INPUT / IMPORT =======
document.getElementById('fileInput').addEventListener('change', async e => {
  if(!e.target.files.length) return;
  toggleLoader(true);
  for(const f of e.target.files) {
    try {
      const url = URL.createObjectURL(f);
      const n = f.name.toLowerCase();
      if(n.match(/\.(glb|gltf)$/)) await load3D(url, n, 'gltf');
      else if(n.match(/\.fbx$/)) await load3D(url, n, 'fbx');
      else if(n.match(/\.obj$/)) await load3D(url, n, 'obj');
      else if(n.match(/\.gif$/)) await loadGif(f, n);
      else if(f.type.startsWith('video/') || n.includes('360') || n.includes('180')) await loadVideo(url, n);
      else if(f.type.startsWith('image/')) await loadImg(url, n);
    } catch(err) {
      console.error('Error al cargar archivo:', f.name, err);
    }
  }
  toggleLoader(false);
  e.target.value = '';
});

async function loadVideo(url, name) {
  const vid = document.createElement('video');
  vid.src = url; vid.crossOrigin = 'anonymous';
  vid.loop = true; vid.muted = true; vid.playsInline = true;
  vid.style.display = 'none'; document.body.appendChild(vid);

  await new Promise(resolve => {
    vid.onloadedmetadata = () => resolve();
    vid.play().catch(e=>console.log("Autoplay prevent:", e));
  });

  const tex = new THREE.VideoTexture(vid);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
  tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;

  let proj = 'plane';
  if(name.includes('360')) proj='360';
  else if(name.includes('180')) proj='180';

  const ar = (vid.videoWidth && vid.videoHeight) ? vid.videoWidth/vid.videoHeight : 1.77;

  const mesh = createMesh(proj, 'sphere', tex, ar);
  const obj = { id: uid(), mesh, name, type:'video', video:vid, tex, settings: defSettings() };
  obj.settings.projection = proj;

  if(proj !== 'plane') {
    obj.mesh.position.set(0, 0, 0);
    obj.settings.scale = 1;
    obj.settings.dist = 0;
  } else {
    obj.mesh.position.set(0, 1.6, -2);
    obj.settings.dist = 2;
  }

  addObj(obj);
}

async function loadGif(file, name) {
  const buf = await file.arrayBuffer();
  // @ts-ignore
  let R = window.GifReader || (window.Omggif ? window.Omggif.GifReader : null);
  if(!R) return;
  const r = new R(new Uint8Array(buf));
  const w=r.width, h=r.height;
  const cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h;
  const ctx=cvs.getContext('2d'); const dat=ctx.createImageData(w,h);
  const tex=new THREE.CanvasTexture(cvs); tex.colorSpace=THREE.SRGBColorSpace;
  tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;

  const mesh = createMesh('plane', 'sphere', tex, w/h);
  mesh.position.set(0, 1.6, -2);
  const obj = { id:uid(), mesh, name, type:'gif', settings:defSettings(), gif:{r,ctx,dat,tex,f:0,num:r.numFrames(),t:0} };
  addObj(obj);
}

async function loadImg(url, name) {
  const tex = await new THREE.TextureLoader().loadAsync(url);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
  const mesh = createMesh('plane', 'sphere', tex, tex.image.width/tex.image.height);
  mesh.position.set(0, 1.6, -2);
  const obj = { id:uid(), mesh, name, type:'image', tex, settings:defSettings() };
  addObj(obj);
}

async function load3D(url, name, type) {
  let m;
  if(type==='gltf') m=(await new GLTFLoader().loadAsync(url)).scene;
  else if(type==='fbx') m=await new FBXLoader().loadAsync(url);
  else m=await new OBJLoader().loadAsync(url);

  const box = new THREE.Box3().setFromObject(m);
  const sz = box.getSize(new THREE.Vector3()).length();
  const sc = (sz>0 && sz<1000) ? 2/sz : 1;
  m.scale.setScalar(sc);
  m.position.set(0, 1, -2);
  m.traverse(c=>{ if(c.isMesh) { c.material.transparent=true; c.material.depthWrite=true; c.castShadow=true; }});

  const obj = { id:uid(), mesh:m, name, type:'model', settings:defSettings() };
  obj.baseScale = sc;
  addObj(obj);
}

// ======= GEOMETR√çAS / SUPERFICIES =======
function createMesh(proj, surface, tex, aspect) {
  let geo, side=THREE.DoubleSide;

  const makeInside = (g)=>{ g.computeVertexNormals(); return g; };

  if(proj === '360') {
    side = THREE.BackSide;
    if(surface === 'cube'){
      geo = makeInside(new THREE.BoxGeometry(40, 40, 40, 1, 1, 1));
    } else {
      geo = makeInside(new THREE.SphereGeometry(20, 64, 64));
      if(surface === 'ovoid'){
        // ovoide = esfera escalada (m√°s ‚Äúhuevo‚Äù)
        geo.scale(1.25, 1.0, 1.0);
      }
    }
  } else if(proj === '180') {
    side = THREE.BackSide;
    if(surface === 'cube'){
      // 180 en cubo: hacemos un ‚Äúhalfbox‚Äù simple usando esfera sigue siendo mejor
      geo = makeInside(new THREE.SphereGeometry(20, 64, 64, 0, Math.PI));
    } else {
      geo = makeInside(new THREE.SphereGeometry(20, 64, 64, 0, Math.PI));
      if(surface === 'ovoid') geo.scale(1.25, 1.0, 1.0);
    }
    geo.rotateY(-Math.PI/2);
  } else {
    geo = new THREE.PlaneGeometry(aspect, 1);
  }

  const mat = new THREE.ShaderMaterial({
    uniforms: {
      map: { value: tex },
      chromaEnabled:{value:false}, chromaInvert:{value:false}, keyColor:{value:new THREE.Color(0,1,0)},
      similarity:{value:0.4}, smoothness:{value:0.1},
      offset:{value:new THREE.Vector2(0,0)},
      opacity:{value:1.0},
      brightness:{value:0.0}, contrast:{value:1.0}, saturation:{value:1.0}, gamma:{value:1.0},
      deblue:{value:0.0}
    },
    vertexShader: vert, fragmentShader: frag,
    transparent: true, side: side,
    depthWrite: (proj==='plane'),
    depthTest: true
  });

  const mesh = new THREE.Mesh(geo, mat);
  if(proj !== 'plane') {
    mesh.frustumCulled = false;
    mesh.renderOrder = -1;
  }
  return mesh;
}

function defSettings() {
  return {
    scale:1, dist:2, height:1.6, rotY:0, projection:'plane',
    surface:'sphere', followViewer:false,
    flipX:false,
    chromaEnabled:false, chromaInvert:false, keyR:0, keyG:1, keyB:0, sim:0.4, smooth:0.05,
    offsetX:0, offsetY:0, opac:1,
    brightness:0, contrast:1, saturation:1, gamma:1,
    deblue:0
  };
}
function uid() { return Math.random().toString(36).substr(2,9); }

function addObj(obj) {
  scene.add(obj.mesh);
  objects.push(obj);
  updateList();
  selectObj(obj.id);
}

// ======= UPDATE OBJ / UI =======
function updateObj(k, v) {
  const o = objects.find(x=>x.id===activeId); if(!o) return;
  o.settings[k]=v;
  const s = o.settings;
  const m = o.mesh;

  // Cambios que requieren recrear geometr√≠a/material (proyecci√≥n/superficie)
  if(k==='projection' || k==='surface') {
    if(o.type==='model') return;

    scene.remove(m);
    let ar=1.77;
    if(o.video) ar=o.video.videoWidth/o.video.videoHeight;
    else if(o.tex && o.tex.image) ar=o.tex.image.width/o.tex.image.height;

    const tex = o.tex || m.material.uniforms?.map.value;
    const nm = createMesh(s.projection, s.surface, tex, ar);
    nm.rotation.copy(m.rotation);
    nm.position.copy(m.position);
    nm.scale.copy(m.scale);

    o.mesh = nm;

    // Reaplicar uniforms desde settings
    applyUniforms(o);

    // Forzar posicionado coherente
    if(s.projection!=='plane'){
      nm.position.set(0,0,0);
      o.settings.dist = 0;
    } else {
      if(Math.abs(o.settings.dist) < 0.01) o.settings.dist = 2;
      nm.position.set(0, o.settings.height, -o.settings.dist);
    }

    scene.add(nm);
    selectObj(o.id);
    return;
  }

  // LOGICA DE ESCALA + ESPEJO (FLIP)
  if(k==='scale' || k==='flipX') {
    const bs = o.baseScale || 1;
    const dir = s.flipX ? -1 : 1;
    m.scale.set(s.scale * bs * dir, s.scale * bs, s.scale * bs);
  }

  // Posici√≥n
  if(s.projection==='plane' || o.type==='model') {
    if(k==='dist') m.position.z = -s.dist;
    if(k==='height') m.position.y = s.height;
  } else {
    // 360/180 normalmente centrados
    m.position.set(0,0,0);
  }

  // Rotaci√≥n Y
  if(k==='rotY') m.rotation.y = THREE.MathUtils.degToRad(s.rotY) + (s.projection==='180'?-Math.PI/2:0);

  // Follow viewer (centrado en observador)
  if(k==='followViewer'){
    // nada inmediato: se aplica en render loop
  }

  // Uniforms (solo media)
  if(o.type !== 'model' && m.material.uniforms) {
    applyUniforms(o);
  }
}

function applyUniforms(o){
  const s=o.settings;
  const m=o.mesh;
  if(o.type === 'model') return;
  if(!m.material?.uniforms) return;
  const u=m.material.uniforms;
  u.chromaEnabled.value=s.chromaEnabled;
  u.chromaInvert.value=s.chromaInvert;
  u.keyColor.value.setRGB(s.keyR, s.keyG, s.keyB);
  u.similarity.value=s.sim;
  u.smoothness.value=s.smooth;
  u.offset.value.set(s.offsetX, s.offsetY);
  u.opacity.value=s.opac;

  u.brightness.value=s.brightness;
  u.contrast.value=s.contrast;
  u.saturation.value=s.saturation;
  u.gamma.value=s.gamma;

  u.deblue.value=s.deblue;
}

const bind = (id, k, type='float') => {
  document.getElementById(id).addEventListener('input', e=>{
    let v=e.target.value;
    if(type==='float') v=parseFloat(v);
    else if(type==='bool') v=e.target.checked;
    updateObj(k,v);
    syncUI();
  });
};

bind('projSelect','projection','str');
bind('surfaceSelect','surface','str');
bind('followViewer','followViewer','bool');

bind('scale','scale');
bind('dist','dist');
bind('height','height');
bind('rotY','rotY');

bind('chromaActive','chromaEnabled','bool');
bind('chromaInvert','chromaInvert','bool');
bind('keyR','keyR'); bind('keyG','keyG'); bind('keyB','keyB');
bind('sim','sim'); bind('smooth','smooth');
bind('offsetX','offsetX'); bind('offsetY','offsetY');
bind('opacity','opac');
bind('brightness','brightness'); bind('contrast','contrast'); bind('saturation','saturation'); bind('gamma','gamma');
bind('deblue','deblue');

bind('checkFlip', 'flipX', 'bool');

function selectObj(id) {
  activeId = id;
  const o = objects.find(x=>x.id===id);

  if(o) {
    // Attach gizmo solo si plane o model (como ten√≠as)
    if(o.settings.projection === 'plane' || o.type === 'model') transformControl.attach(o.mesh);
    else transformControl.detach();

    const isMedia = (o.type !== 'model');
    document.getElementById('mediaControls').style.display = isMedia ? 'block' : 'none';
    document.getElementById('generalControls').style.display = 'block';

    syncUI();
  } else {
    transformControl.detach();
    document.getElementById('mediaControls').style.display = 'none';
  }
  updateList();
}

function syncUI() {
  const o = objects.find(x=>x.id===activeId); if(!o) return;
  const s = o.settings;

  const set = (id, v) => {
    const el=document.getElementById(id);
    if(el && el.type !== 'checkbox') el.value=v;
    const t=document.getElementById('v_'+id);
    if(t) t.innerText=(typeof v==='number') ? v.toFixed(2) : v;
  };

  // Proyecci√≥n
  if(o.type!=='model') document.getElementById('projSelect').value = s.projection;

  const is360 = (s.projection === '360' || s.projection === '180');
  document.getElementById('posControls').style.display = is360 ? 'none' : 'block';

  document.getElementById('surfaceRow').style.display = is360 ? 'flex' : 'none';
  document.getElementById('followRow').style.display = is360 ? 'flex' : 'none';
  if(is360){
    document.getElementById('surfaceSelect').value = s.surface || 'sphere';
    document.getElementById('followViewer').checked = !!s.followViewer;
  }

  set('scale',s.scale);
  if(!is360) {
    set('dist',Math.abs(o.mesh.position.z));
    set('height',o.mesh.position.y);
  }
  set('rotY',s.rotY);
  document.getElementById('checkFlip').checked = s.flipX;

  if(o.type !== 'model' && o.mesh.material.uniforms) {
    document.getElementById('chromaActive').checked = s.chromaEnabled;
    document.getElementById('chromaInvert').checked = s.chromaInvert;
    set('keyR',s.keyR); set('keyG',s.keyG); set('keyB',s.keyB);
    document.getElementById('colorPrev').style.background = `rgb(${s.keyR*255},${s.keyG*255},${s.keyB*255})`;
    set('sim',s.sim); set('smooth',s.smooth);
    set('offsetX',s.offsetX); set('offsetY',s.offsetY);
    set('opacity',s.opac);
    set('brightness',s.brightness); set('contrast',s.contrast); set('saturation',s.saturation); set('gamma',s.gamma);
    set('deblue', s.deblue);
  }
}

window.centerActive = () => {
  const o=objects.find(x=>x.id===activeId);
  if(!o) return;
  if(o.settings.projection==='plane' || o.type==='model'){
    o.mesh.position.set(0,1.6,-2);
    o.mesh.rotation.set(0,0,0);
    o.settings.dist=2; o.settings.height=1.6; o.settings.rotY=0;
    syncUI();
  }
};

window.reloadVideo = () => {
  const o=objects.find(x=>x.id===activeId);
  if(o && o.video) { o.video.pause(); o.video.currentTime=0; o.video.play().catch(e=>console.log(e)); }
};

window.deleteActive = () => {
  const i = objects.findIndex(x=>x.id===activeId);
  if(i>-1) {
    const o=objects[i];
    scene.remove(o.mesh);
    if(o.video){o.video.pause();o.video.remove();}
    if(o.mesh.geometry)o.mesh.geometry.dispose();
    objects.splice(i,1);
    activeId=null;
    selectObj(null);
  }
};

function updateList() {
  const l=document.getElementById('layerList'); l.innerHTML='';
  objects.forEach(o=>{
    const d=document.createElement('div');
    d.className=`layer-item ${o.id===activeId?'active':''}`;
    d.innerHTML=`<span>${o.type==='model'?'üì¶':(o.settings.projection==='360'||o.settings.projection==='180'?'üåê':'üé¨')}</span> <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${o.name}</span>`;
    d.onclick=()=>selectObj(o.id);
    l.appendChild(d);
  });
}

window.toggleUI=()=>document.getElementById('ui').classList.toggle('hidden');

document.getElementById('checkOcclusion').addEventListener('change', e => {
  if(xrSession) alert("Para cambiar la oclusi√≥n real (Depth API), sal y vuelve a entrar en MR.");
});

function toggleLoader(s){document.getElementById('loader').style.display=s?'flex':'none';}

// ======= Mouse picking (Editor) =======
function initMousePick(){
  raycaster = new THREE.Raycaster();
  renderer.domElement.addEventListener('pointerdown', (ev)=>{
    if(xrSession) return; // en XR se selecciona con ray de controladores
    if(transformControl.dragging) return;

    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;

    const targets = objects
      .filter(o=>o.settings.projection==='plane' || o.type==='model')
      .map(o=>o.mesh);

    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(targets, true);
    if(hits.length){
      let m = hits[0].object;
      const found = objects.find(o => { let x=m; while(x){ if(x===o.mesh) return true; x=x.parent; } return false; });
      if(found) selectObj(found.id);
    }
  });
}

// ======= Shortcuts (Editor) =======
function initShortcuts(){
  window.addEventListener('keydown', (e)=>{
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA')) return;

    if(e.key === 'Delete' || e.key === 'Backspace'){
      deleteActive();
    }
    if(e.key.toLowerCase() === 'g') transformControl.setMode('translate');
    if(e.key.toLowerCase() === 'r') transformControl.setMode('rotate');
    if(e.key.toLowerCase() === 's') transformControl.setMode('scale');
    if(e.key === 'Escape') transformControl.detach();

    // Ejes (opcional)
    if(e.key.toLowerCase() === 'x') transformControl.showX = true;
    if(e.key.toLowerCase() === 'y') transformControl.showY = true;
    if(e.key.toLowerCase() === 'z') transformControl.showZ = true;
  });
}

// ======= GIF playback =======
function tickGifs(dt){
  for(const o of objects){
    if(!o.gif) continue;
    const g=o.gif;
    g.t += dt;
    if(g.t < 1/24) continue; // 24 fps aprox
    g.t = 0;
    g.r.decodeAndBlitFrameRGBA(g.f, g.dat.data);
    g.ctx.putImageData(g.dat,0,0);
    g.tex.needsUpdate = true;
    g.f = (g.f+1) % g.num;
  }
}

// ======= VR SETUP =======
function setupVR() {
  if('xr' in navigator) {
    navigator.xr.isSessionSupported('immersive-ar').then(s=>{
      if(s) {
        const b=document.getElementById('vrBtn');
        b.style.display='block';
        b.onclick=startVR;
      }
    });
  }
}

async function startVR() {
  const useOcclusion = document.getElementById('checkOcclusion').checked;
  const sessionInit = {
    requiredFeatures: ['local-floor'],
    optionalFeatures: ['dom-overlay'],
    domOverlay: { root: document.body }
  };

  if(useOcclusion) {
    sessionInit.optionalFeatures.push('depth-sensing');
    sessionInit.depthSensing = {
      usagePreference: ["gpu-optimized", "cpu-optimized"],
      dataFormatPreference: ["luminance-alpha"]
    };
  }

  xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);
  renderer.xr.setSession(xrSession);

  setMode(true);

  xrSession.addEventListener('end', ()=>{
    xrSession=null;
    setMode(false);
  });
}

// ======= CONTROLES VR (lo tuyo + selecci√≥n segura) =======
function initRay() {
  rightRay = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]),
    new THREE.LineBasicMaterial({color:0x6c5ce7})
  );
  scene.add(rightRay);
  rayCursor = new THREE.Mesh(new THREE.SphereGeometry(0.02), new THREE.MeshBasicMaterial({color:0xff7675}));
  scene.add(rayCursor);
}

function handleVR(frame, dt) {
  if(!xrSession) return;
  const ref = renderer.xr.getReferenceSpace();
  let lSrc, rSrc;
  for(const s of xrSession.inputSources) { if(s.handedness==='left') lSrc=s; if(s.handedness==='right') rSrc=s; }

  if(rSrc && rSrc.gripSpace) {
    const p = frame.getPose(rSrc.gripSpace, ref);
    if(p) {
      const pos = p.transform.position;
      rightRay.position.set(pos.x,pos.y,pos.z);
      rightRay.quaternion.set(p.transform.orientation.x,p.transform.orientation.y,p.transform.orientation.z,p.transform.orientation.w);
      rightRay.visible = true;

      const orig = new THREE.Vector3(pos.x, pos.y, pos.z);
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(rightRay.quaternion);
      const targets = objects.filter(o=>o.settings.projection==='plane'||o.type==='model').map(o=>o.mesh);
      const hits = new THREE.Raycaster(orig, dir, 0, 10).intersectObjects(targets, true);

      if(hits.length>0) {
        rayCursor.visible = true; rayCursor.position.copy(hits[0].point);
        let m = hits[0].object;
        const found = objects.find(o => { let x=m; while(x){if(x===o.mesh)return true; x=x.parent;} return false; });
        hoverId = found ? found.id : null;
      } else { rayCursor.visible=false; hoverId=null; }

      ctrl.right.currPos = orig;
      ctrl.right.currQuat = rightRay.quaternion.clone();
    }
  }

  if(rSrc && rSrc.gamepad) {
    const gp = rSrc.gamepad;
    const trig = gp.buttons[0].pressed;
    const grip = gp.buttons[1].pressed;
    const btnA = gp.buttons[4]?.pressed || gp.buttons[5]?.pressed;

    // A: play/pause
    if(btnA && !ctrl.right.lastBtn && activeId) {
      const o = objects.find(x=>x.id===activeId);
      if(o && o.video) { if(o.video.paused) o.video.play(); else o.video.pause(); }
    }
    ctrl.right.lastBtn = btnA;

    const sx = gp.axes[2]||0; const sy = gp.axes[3]||0;
    if(trig && !ctrl.right.lastTrig && hoverId) selectObj(hoverId);
    ctrl.right.lastTrig = trig;

    // Grip: mover/rotar/escalar (como ten√≠as)
    if(grip) {
      const obj = objects.find(o=>o.id===activeId);
      if(obj) {
        if(obj.settings.projection==='plane'||obj.type==='model') {
          if(Math.abs(sx)>0.1) obj.mesh.position.x += sx*dt*2;
          if(Math.abs(sy)>0.1) obj.mesh.position.z += sy*dt*2;
          if(ctrl.right.gripped) {
            const dQ = ctrl.right.currQuat.clone().multiply(ctrl.right.lastQuat.clone().invert());
            obj.mesh.quaternion.premultiply(dQ);
            syncUI();
          }
        }

        if(lSrc && lSrc.gamepad) {
          const lGrip = lSrc.gamepad.buttons[1].pressed;
          const lsy = lSrc.gamepad.axes[3]||0;
          if(Math.abs(lsy)>0.1 && (obj.settings.projection==='plane'||obj.type==='model')) { obj.mesh.position.y -= lsy*dt; syncUI(); }

          if(lGrip) {
            const lp = frame.getPose(lSrc.gripSpace, ref);
            if(lp) {
              const lPos = new THREE.Vector3(lp.transform.position.x, lp.transform.position.y, lp.transform.position.z);
              const d = lPos.distanceTo(ctrl.right.currPos);
              if(!ctrl.left.gripped) { ctrl.gesture.startDist=d; ctrl.gesture.startScale=obj.settings.scale; }
              else {
                const ns = Math.max(0.1, ctrl.gesture.startScale * (d/ctrl.gesture.startDist));
                updateObj('scale', ns);
              }
            }
            ctrl.left.gripped = true;
          } else ctrl.left.gripped = false;
        }
      }
      ctrl.right.gripped = true; ctrl.right.lastQuat.copy(ctrl.right.currQuat);
    } else ctrl.right.gripped = false;
  }
}

// ======= Render loop =======
let lastT = performance.now();
function render(t, frame) {
  const dt = Math.min(0.05, (t-lastT)/1000);
  lastT = t;

  // editor orbit
  if(!xrSession) orbit.update();

  // gifs
  tickGifs(dt);

  // Follow viewer para 360/180
  for(const o of objects){
    if(o.type === 'model') continue;
    const s=o.settings;
    if((s.projection==='360' || s.projection==='180') && s.followViewer){
      const cam = renderer.xr.isPresenting ? renderer.xr.getCamera(camera) : camera;
      o.mesh.position.copy(cam.position);
    }
  }

  // vr controls
  if(frame) handleVR(frame, dt);

  renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
